高级linux程序设计
-----------



起步
--


- 用 Emacs 进行编辑优点:
 
 >-  自动化排版
 >- 语法高亮

- GCC 编译

 Linux系统中提供的编译器全部来自GNU编译器集合(GNU Compiler Collection),通常被称为GCC。 GCC中包含了C、C++、Java、Objective-C、Fortran和Chill语言的编译器。

 >-I 选项会告诉编译器去哪里寻找包含文件。默认情况下,GCC 会在当前目录及标准库的包含文件所在的路径搜索程序所需的包含文件。如果你需要从其它的路径中搜索包含文件,你就需要通过 –I 选项指定这个路径。假设你的项目中包含一个用于保存源码文件的 src 目录,以及一个用于存放包含文件的 include 目录。你应该这样写: 
>         g++ -c –I ../include 源程序文件名
       **NDEBUG 宏可以用于关闭断言检查。**
直接通过命令行定义 NDEBUG 宏: 
       g++ -c –D NDEBUG 源程序
如果你希望将 NDEBUG 宏定义为某个特定的值,下面这个命令行可以做到:  
 g++ -c –D NDEBUG=3 源程序

 如果你现在编译的正是准备发布的版本,你或许希望GCC 能将得到的代码尽量优化以提高运行速度。你可以通过指明 -O2 选项要求 GCC 进行代码优化。(GCC 有许多不同等级的代码优化,不过2级对多数情况都是适当的.) 下面的命令可以打开优化并编译:
                    g++ -c –O2  源程序
 > 需要注意的是,优化选项会导致你的程序难以被调试程序调试。此外,在某些特例中,启用了优化的编译可能会将一些之前没有被发现的 bug显现出来.可以在命令行下输入以下命令以获取文档:             info gcc

- GNU Make 自动完成编译过程

 告诉 make 程序你需要完成什么 目标( target ) ,以及达成这些目标的 规则( rules ) 。你还可以通过指定 依赖关系( dependency ) 指明需要重新构建某些目标的条件。

 除了这些显而易见的目标,你始终应该指定一个名为 clean 的目标。这个目标对应的规则是删除所有编译生成的对象文件和程序文件,因此下次编译将是从头开始。这个目标的规则通常使用 rm 命令进行删除操作。

 目标写在最左侧一列,之后跟随一个冒号,然后是所有依赖项。用于构建目标的对应规则写在紧接着的下一行。**包含规则的行必须以一个 Tab 字符(退格键)起头,否则 make 程序将无法识别。**如果你用Emacs 编辑 Makefile,Emacs 会帮助你打理排版方面的节。

 $(CFLAGS) 是一个 make 变量。你可以在 Makefile 中定义这个变量,也可以在命令行中定义。GNU make 会在执行这个规则的时候将变量的值代入。因此,假如要让编译器打开优化并重新编译程序,你可以这样操作:    make clean
          rm –f *.o reciprocal
          make CFLAGS=-O2
          gcc -O2 –c 源程序

 即-O2被替换到了先前每个$(CFLAGS) 出现的地方。

- GDB 进行调试

>- 在编译时加入调试信息

>  要使用 GDB,你必须在编译时为对象文件加入调试信息。只需在编译器选项中加入 –g 就可以做到这点。

>- 运行 GDB

>  通过 where 命令查看调用堆栈;通过 up 命令沿着调用堆栈向上回溯;可以用 print 命令查看变量的值;可以利用 break 命令为程序设置断点;利用 next 命令可以单步追踪程序;
>可以通过命令 M-x gdb 在一个 Emacs 窗口中启动 gdb 调试器。当你在一个断点处停止的时候,Emacs会自动现实对应的源码文件。通常来说,相比只能看见一行程序的情况,能够通读整个文件更容易让你找到头绪。

- 运行 whatis name 会显示系统中所有名称匹配的、位于任意章节中的所有手册页的介绍。如果你不清楚你要找的命令或函数的名字,你可以通过 man –k keyword 命令进行查找。

- Info 文档系统提供了更加详细的文档,范围涵盖了 GNU/Linux 系统的许多核心部件以及其它一些程序。Info 页面是一种与 HTML 页面类似的超文本文档。只需要在一个终端窗口输入 info 就可以启动文本界面的 Info 浏览器。首先你将看到的是在你的系统中已安装的所有Info页面的列表。(按下 Ctrl+H 键会显示用于浏览 Info 文档的键盘配置。)
如果你在 Emacs 中完成多数的编程任务,你可以使用 Emacs 内置的 Info 浏览器。它的调用命令是 M-x info 或 C-h i。

- 你可以通过阅读系统包含文件来获取与系统函数相关的知识。这些包含文件位于/usr/include 和 /usr/include/sys 目录下。在 Linux 系统中,关于系统调用如何工作的各种细节信息都会从一些包含文件中反应出来;它们位于 /usr/include/bits、/usr/include/asm 和 /usr/include/sys 目录下。通常 Linux 内核的源码被安放在 /usr/src/linux 目录中。

编写优质 GNU/Linux 软件
-----------------

介绍了多数 GNU/Linux 程序员会使用的一些基本技巧。如果在你的程序中遵循这些约定,你的程序就可以在 GNU/Linux 系统环境下很好地工作,并且能符合用户关于程序间协作的习惯与期望。

- 与运行环境交互

>- 参数列表

>  可以通过在命令 shell 的提示符后输入一个程序的名字来运行一个程序。你也可以选择在程序名后跟一个或多个用空格分隔的单词。这部分输入被称为命令行参数( command-line arguments ) 。。你可以通过将一个参数用引号保护起来,使某个参数内可以包含空格。更加常见的说法是将它称为参数列表,因为这些参数未必是来自 shell 程序。

   >    当从 shell 调用一个程序的时候,参数列表中包含了整个命令行,包含了程序的名字和全部被指定的命令行参数。
>    程序的 main 函数可以通过参数 argc 和 argv 来访问程序的参数列表(如果你不需要访问参数列表,你可以直接忽略它们)。第一个参数 argc 指示了命令行中参数的数量。第二个参数 argv 是一个字符串数组。数组的大小由 argc 指定,而数组的元素则为各个命令行参数的元素,表示以 NULL 结束的字符串形式。
 
 >- GNU/Linux 系统命令行使用习惯

 >   几乎所有 GNU/Linux 程序都遵循一些处理命令行参数的习惯。程序期望得到的参数可以被分为两种: 选项( options ,又作 flags ) 和其它(非选项)参数。选项用于调整程序的行为方式,而其它参数提供了程序的输入(例如,输入文件的名字)。
 >>选项通常有两种格式:
>>- 短选项( short options ) 由一个短杠(hyphen)和一个字符(通常为一个大写或小写字母)组成。短选项可以方便用户的输入。
 >>- 长选项( long options ) 由两个短杠开始,之后跟随一个由大小写字母和短杠组成的名字。长选项方便记忆和阅读(尤其在脚本中使用的时候)。

 >   通常程序会为它支持的选项提供长短两种形式,前者为便于用户理解,而后者为简化输入。选项 –s 改变了 ls 的默认行为方式,通知它为每个条目显示文件大小(以 KB 为单位)。参数 / 向 ls 指明了被列举的目录。选项 –size 与 –s 选项具有相同的含义,因此调用 ls –size / 会得到完全相同的结果。
 >- 使用 getopt_long
 
 >  函数 getopt_long 能够处理长短两种格式的选项。要使用这个函数,请包含头文件< getopt.h>。第一个数据结构是一个字符串,其中包含了所有有效的短格式选项,每个字母表示一个。如果一个选项要求一个参数标记为在名称后加一个冒号。对于这个程序而言,字符串 ho:v 指明了程序的可用选项包括 –h, -o 和 –v,其中第二个选项要求一个参数。
 
 >  要指明程序接受的长选项,你需要建立一个 struct option 类型的数组。数组的每个元素都针对一个长选项且每个元素都具有四个域。一般情况下,第一个域是长选项的名字(表示为一个字符串;不包含选项开始的两个短杠);第二个参数如果为 1 则表示该选项接受一个参数,否则为 0;第三个域指定为 NULL;第四个参数则为一个字符常量,保存了相同含义的短选项名。数组中最后一个元素的所有域都应为 0。

>>  当你调用 getopt_long 的时候,并且传递给它以下这些参数:

>>- main 函数的参数 argc 和 argv;
>>- 描述短选项的字符串;
>>- 描述长选项的 struct options 数组。

>>当使用 getopt_long 的时候:

>>- 每次调用 getopt_long 的时候,它解析一个选项,返回这个选项对应的短格式字母。如果没有其它选项则返回 -1。
>>- 这个函数的典型用法是在一个循环中不断调用以处理用户指明的所有选项,且程序在一个 switch 语句中分别处理每个选项。
>>- 如果 getopt_long 检测到一个无效选项(一个没有被指定为任何长短选项的选项),它会输出一条错误消息并返回字符’?’(一个英文问号)。多数程序通常会在这种情况下显示使用帮助并退出。
>>- 当处理一个带参数的选项时,全局变量optarg 将指向参数字符串的开始。
>>- 当 getopt_long 结束处理所有选项之后,全局变量 optarg 包含了第一个非选项参数在 argv 中的索引。
 
  >- 标准 I/O

>   标准 C 库提供了标准输入和输出流(分别为 stdin 和 stdout)。它们被用于 scanf、printf和其它库函数中。C 库还提供了标准错误流 stderr。程序应该将警告和错误信息输出到标准错误流而不是标准输出流。这样方便了用户区别对待普通程序输出和错误输出,比如将标准输出重定向到一个文件而让标准错误显示在终端里。可以通过 fprintf 函数向标准错误流输出信息:           fprintf (stderr, (“Error: ...”));这三个流也可以文件描述符的形式通过底层 UNIX I/O 命令(read、 write 等)进行操作。**文件描述符 0 代表标准输入,1 为标准输出而 2 为标准错误。**
>   
>   2&1 的语法表示文件描述符 2(stderr)应并入文件描述符 1(stdout)。注意,2>&1 这个语法必须出现在文件重定向之前(如第一个例子所示)或者管道重定向之前.需要注意的是,stdout 是经过缓冲处理的。写入 stdout 的数据不会立刻被写入终端(或其它设备,如果程序输出被重定向)除非缓冲区满、程序正常退出或 stdout 被关闭。你可以这样显式地刷新输出流:     
>                  fflush (stdout);    
>与stdout不同的是, stderr没有经过缓冲处理;输出到stderr的数据会直接被发送到终端。
>- 程序退出代码

>   当一个程序结束的时候,它会通过一个退出代码表示自己的运行结果。退出代码是一个小整数值。一般的习惯是,返回 0 表示正常,而非 0 表示错误的出现。一些程序通过不同的非 0 值表示不同的错误情况。在许多 shell 中,可以通过特殊环境变量$?得到最近执行的一个程序的退出代码。

>- 环境

>   GNU/Linux 为每个运行程序提供了一个 环境( environment )。环境是一组“键-值”对的集合。环境变量名和它们的值都是字符串。

> >环境变量名通常由大写字母组成。

>>- USER 包含了你的用户名。
>>- HOME 包含了你的个人目录 ( home directory ) 的位置。
>>- PATH 包含了一些文件夹路径,之间由冒号进行分隔。Linux 系统在这些文件夹中搜索可执行程序。
>>- DISPLAY 包含了 X 窗口服务器的名称和显示器编号。这里指定的 X 服务器和显示器编号将是基于 X 的图形程序运行时将会出现的地方。

 >Shell 提供了直接查看和修改环境的方法。可以使用 printenv 程序输出完整的当前环境。不同的 shell 程序通过不同的内建语法使用环境变量的值
 >>- Shell 会自动为每个检测到的环境变量设置一个 Shell 变量,因此你可以通过$变量名的语法访问环境变量。
 >>- 可以通过 export 命令将一个 shell 变量加入环境中。

>  程序中可以使用< stdlib.h>中提供的 getenv 函数访问环境变量。这个函数接受一个包含变量名的字符串作为参数,并返回包含了相应的环境变量值的字符串。如果参数中指定的环境变量不存在,getenv 将返回 NULL。而 setenv 和 unsetenv 函数则分别可用于设置和清除环境变量。列举所有环境变量需要一点技巧。你需要通过访问一个叫做 environ 的全局变量来列举所有环境变量。这个变量是由 GNU C 库定义的。它是一个 char **类型的变量,包含了一个以 NULL 指针结束的字符串数组。每个字符串都包含了一个环境变量。这个环境变量被表示为“变量=值”的形式。
不要直接修改 environ 变量;如果需要修改环境变量,则应通过 setenv 和 unsetenv 函数完成。

>- 使用临时文件

> 有时候程序需要使用临时文件,用来缓存或者向别的程序传递大量的数据。在GNU/Linux 系统中,临时文件被存储在 /tmp 文件夹下。当使用临时文件的时候,你需要注意以下的问题:

>>- 同一个程序的多个副本可能正在(由同一个用户或不同的用户)并行运行。每个副本都应该使用不同的临时文件以避免冲突。
>>- 文件权限的设置应当保证临时文件不会被未被授权的用户修改或替换,从而导致程序行为被改变。
>>- 生成的临时文件名应该不可被外界预料;否则,攻击者可能会在程序检测一个文件名是否被占用与实际打开临时文件进行读写之间的间隔进行攻击。

>    函数 mkstemp 从一个文件名模板生成临时文件名,创建这个临时文件,将模式设置为仅当前用户可以访问,并且以读写权限打开这个文件。文件名模板是一个字符串,其结尾应为“XXXXXX”(六个大写字X);mkstemp 函数用其它字符替换这些 X 以得到一个不重复的文件名。函数返回已打开的文件描述符;可以通过 write 族的函数对它执行写入操作。

>由 mkstemp 创建的临时文件是不会被自动删除的。是否删除、以及在何时删除这些临时文件完全取决于你。(程序员应该时刻记住及时清理临时文件,否则一旦 /tmp 文件夹被填满,系统将不可用。)如果这个临时文件只是程序内部使用而不会移交给其它程序,在创建之后立刻调用 unlink 是个不错的主意。这个函数会从目录中移除对应的文件项,但是文件系统中的文件是有引用计数的,因此只有当所有指向该文件的描述符都被关闭的时候,它才会被文件系统真正删除。通过这个方法,你的程序可以继续使用这个临时文件,而这个临时文件会在你关闭文件描述符的时候被清除出系统。因为 Linux 系统会在程序结束的时候关闭所有文件描述符,即使你的程序被异常终止,临时文件仍然会被删除。

>如果你使用的是 C 库 I/O 函数,且你不需要向其它程序传递这个临时文件,你可以使用tmpfile 函数。这个函数创建并打开一个临时文件并返回一个对应的文件指针。如前例中所示,这个临时文件已经被 unlink,因此当文件指针被关闭(通过 fclose)或程序结束的时候临时文件将被自动删除。

>  GNU/Linux 提供了其它一些用于生成临时文件或文件名的函数,包括 mktemp、 tmpnam和 tempnam 等。不要使用这些函数,因为这些函数在可靠性和安全性方面存在不足。

- 防御性编码
写一个程序在“普通”状态下正常运行不是一件容易的事情;要让程序在运行出错的情况下表现得优雅就更难了。所以应该学会在编码阶段尽早发现错误,以及使程序在运行中检测和恢复错误状况的出现。

>- 使用 assert
>构造一个应用程序的时候,应该始终记住:应该让程序在出现 bug 或非预期的错误的时候,应该让程序尽可能早地突然死亡。这样做可以帮助你在开发和测试循环中尽早地发现错误。不导致突然死亡的错误将很难被发现;它们通常会被忽略,直到程序在客户系统中运行以后才被注意到。

>  检查非预期状态的最简单的方式是通过标准 C 库的 assert 宏。这个宏的参数是一个布尔表达式(Boolean expression)。当表达式的值为假的时候,assert 会输出源文件名、出错行数和表达式的字面内容,然后导致程序退出。Assert 宏可用于大量程序内部需要一致性检查的场合。例如,可以用 assert 检查程序参数的合法性、检查函数(或 C++中的类方法)的前提条件和最终状态(postcondition)、检查非预期的函数返回值,等等。

>   每次使用 assert 宏,不仅可以作为一项运行期的检查,还可以被当作是嵌入代码中的文档,用于指明程序的行为。如果你的程序中包含了assert( condition ),它就是在告诉阅读代码的人:condition 在这里应该始终成立;否则很可能是程序中的 bug。对于效率至上的代码,assert 这样的运行时检查可能引入严重的效率损失。在这种情况下,你可以定义 NDEBUG 宏并重新编译源码(可以通过在编译器参数中添加 –DNDEBUG参数做到)。在这种情况下,assert 宏的内容将被预处理器清除掉。应该只在当效率必须优先考虑的情况下,对包含效率至上的代码的文件设置 NDEBUG 宏进行编译。

>   因为 assert 可能被预处理过程清除,当使用这个宏的时候必须确信条件表达式不存在副作用。特别的,不应该在 assert 的条件表达式中使用这些语句:函数调用、对变量赋值、使用修改变量的操作符(如 ++ 等)。

>   不应该使用 assert 去检测不合法的用户输入。用户即使在输入不合适的信息后也不希望看到程序仅在输出一些含义模糊的错误信息后溃。你应该检查用户的非法输入并向用户返回可以理解的错误信息。只当进行程序内部的运行时检查时才应使用 assert 宏。

>>一些建议使用 assert 宏的地方:

>>- 检查函数参数的合法性,例如判断是否为 NULL 指针。由 { assert (pointer !=NULL)} 得到的错误输出 
>    Assertion ‘pointer != ((void *)0)’ failed.
与当程序因对 NULL 指针解引用得到的错误信息
        Segmentation fault (core dumped)相比而言要清晰得多。
>>- 检查函数参数的值。例如,当一个函数的 foo 参数必须为正数的时候我们可以在函数开始处进行这样的检查:         assert (foo > 0);  这会帮助你发现错误的调用;同时它很清楚地告诉了读代码的人:这个函数对参数的值有特殊的要求。

>- 系统调用失败
>
>  当通过系统调用访问系统资源、执行 I/O 或其它命令的时候,除了理解执行成功的意义,更应该明白出现错误可能出现的时机和原因。

>>系统调用可能由于各种原因而失败。例如:
>
>>- 系统可能出现资源短缺(或程序用尽了系统为单个程序设置的资源使用限制)。例如,程序正在尝试分配过多的内存,向磁盘写入过多信息或同时打开过多的文件,等等。
>>- 当程序尝试执行某些自身权限不允许的操作的时候,系统可能会致使执行失败。例如,程序尝试向一个设置为只读权限的文件写入信息、访问属于另外一个进程的内存或杀死其它用户运行的程序等。
>>- 系统调用可能由于程序之外的原因而失败。这种情况常见于通过系统调用访问硬件设备的时候。这个设备可能不能正常工作、可能不支持特定的操作,也可能是处于类似“没有将磁碟插入驱动器”这样的情况中。
>>- 系统调用可能因为外部的事件(如信号等)而被中断。这可能不代表彻底的执行失败,但是如果需要,程序应当重新尝试执行系统调用。

>>在一个好的、大量使用系统调用的程序中,很多情况下,多数的代码将被用于检测、处理错误和其它意外情况,而不是用于完成程序的主要任务。

>- 系统调用返回的错误码

>    多数系统调用在成功执行之后返回 0,而在失败的时候返回非 0 值。(不过,也有许多函数通过返回值表示不同的意义;例如,malloc 在执行失败后返回空指针。

>   尽管这些信息足够用于判定程序是否应该继续执行,它并不足以让程序清楚地了解如何对已经出现的错误进行恢复和处理。
>   多数系统调用在执行失败的时候会通过一个特殊的全局变量errno保存错误相关的信息。当执行失败的时候,系统调用会将errno设置为特定的值以指示错误原因。因为所有系统调用均会使用errno指示出现的错误,你应该在出现错误之后立刻将errno的值保存到其它的变量中。在此之后的系统调用过程可能在出错的情况下覆盖现有的值。错误代码是整型的;可能值均通过预处理宏指定了。这些宏的命名均为错误的约定名字的全部大写形式加上前缀 E 构成——例如“EACCES”和“EINVAL”等。始终应该通过这些宏表示 errno 的值,而不是直接使用整数。如果要使用这些错误代码,则需要在程序中包含< errno.h>。

>   GNU/Linux 提供了 strerror 函数以简化错误处理。这个函数用于返回一个 errno 错误代码对应的说明性字符串。这个字符串可以用于程序输出的错误信息中。使用 strerror 需要在程序中包含< string.h>。
>   
>   GNU/Linux 还提供了 perror 函数。这个函数会直接将错误信息输出到 stderr 流。传递给 perror 的参数是一个前缀字符串;当函数执行的时候,这个字符串将作为错误信息的前缀输出,因此通常可以在这个字符串中说明出错的函数。使用 perror 需要在程序中包含< stdio.h>。

>   取决于你的程序和系统调用本身的特性,当出错的时候你可以选择输出错误信息、取消一个操作、强制退出程序、重新尝试调用甚至是直接忽略这个错误。不过,包含一段通过某种方式处理所有错误情况的程序逻辑是非常必要的。有一个你始终应该注意(尤其在执行 I/O 操作的时候)的错误代码是 EINTR。某些函数,如 read、write 和 sleep 等,可能需要很长时间才能执行完毕。这些函数被成为 阻塞( blocking ) 函数,因为程序的执行会被阻塞直到这个函数调用结束。但是,当程序在阻塞过程中收到一个信号,这些函数可能不等执行完毕就直接返回。在这种情况下,errno 被设置为 EINTR。通常在这种时候你应该尝试重新执行这个操作。

>- 错误与资源分配

>    很多情况下,当一个系统调用失败的时候程序可以选择取消当前的操作而不终止运行,因为这些错误是可以恢复的。一种方式是从当前函数中返回,通过将错误代码传回给调用者表示错误的出现。

>   如果你决定从函数当中返回,必须确保函数中已经成功分配的资源必须首先被释放。这些资源可能包括内存、文件描述符、文件指针、临时文件、同步对象等。否则,如果你的程序继续保持运行,这些资源将被泄漏。										
>
>  Linux 会在程序退出的时候清理分配的内存、打开的文件和其它绝大多数资源,因此在调用 exit 之前释放缓冲区并关闭文件。不过,你可能需要手工释放其它资源,如临时文件和共享内存等——这些资源在进程结束后仍然存在。								

- 编写并使用程序库

每个程序都链接到一个或几个库上。任何一个使用了 C 函数(诸如printf 等)都须链接到 C 运行时库。如果你的程序具有图形界面(GUI),它将被链接到窗口系统的库。如果你的程序使用了数据库,数据库供应商会提供给你一些简化访问数据库的库。

在这些情况中,你必须作出选择: 静态( statically ) 还是 动态( dynamically ) 地将程序链接到库上。如果你选择了静态链接,程序体积可能会更大,程序也会比较难以升级,但是可能相对而言比较易于部署。如果你选择动态链接,则程序体积会比较小、易于升级,但是部署的难度将会有所提高。
											
		
>- 存档文件
>											
>  存档文件( archive ) ,也被称为静态库(static library),是一个存储了多个对象文件(object file)的单一文件。(与 Windows 系统的 .LIB 文件基本相当。)编译器得到一个存档文件后,会在这个存档文件中寻找需要的对象文件,将其提取出来,然后与链接一个单独的对象文件一样地将其链接到你的程序中。你可以使用 ar 命令创建存档文件。传统上,存档文件使用 .a 后缀名,以便与 .o 的对象文件区分开。下面的命令可以将 test1.o 和 test2.o 合并成一个 libtest.a 存档:
       ar cr libtest.a test1.o test2.o
上面命令中的cr选项通知ar创建这个存档文件	现在你可以通过为gcc或g++指定 –ltest参数将程序链接到这个库。	当链接器在命令行参数中获取到一个存档文件时,它将在其中搜索所有之前已经被引用而没有被定义的符号(函数或变量)的定义。定义了这些符号的对象文件将从存档中被提取出来,链接到新程序执行文件中。因为链接器会在读取命令行参数的过程中一遇见存档文件就进行解析,通常将存档文件放在命令行参数的最后最有意义。	

>- 共享库	
											
>   共享库( shared library ,也被称为共享对象 shared object 或动态链接库 dynamically linked library ) 在某种程度上与由一组对象文件生成的打包文件相当类似。不过,两者之间的区别也是非常明显的。最本质的区别在于,当一个共享库被链接到程序中的时候,程序本身并不会包含共享库中出现的代码。程序仅包含一个对共享库的引用。当系统中有多个程序链接到同一个共享库的时候,它们都将引用这个共享库而不是将代码直接包含在自身程序中——正因为如此,我们说这个库被所有这些程序“共享”。					

 >  第二个重要的区别在于,共享库不仅仅是对象文件的简单组合。当使用的时候,链接器会从中寻找需要的部分进行链接,以匹配未定义的符号引用。而当生成共享库的时候,所有对象文件被合成为一个单独的对象文件,从而使链接到这个库的程序总能包含库中的全部代码,而不仅仅是所需要的部分。

 >  要创建一个共享库,你必须在编译那些用于生成共享库的对象时为编译器指定 –fPIC 选项。  
 >   命令:    gcc –c –fPIC 源程序  
 >   –fPIC选项会通知编译器你要将得到的 *.o 作为共享库的一部分。然后你将得到的对象文件合并成一个共享库:
% gcc –shared –fPIC –o libtest.so test1.o test2.o
>这里 –shared 选项通知链接器生成共享库,而不是生成普通的可执行文件。共享库文件通常使用 .so 作为后缀名,这里 so 表示共享对象(shared object)。与静态库文件相同,文件名以 lib 开头,表示这是一个程序库文件。将程序链接到共享库与链接到静态库的方法并无二致。
											
>>位置无关代码(Position-Independent Code)

>>共享库中的函数在不同程序中可能被加载在不同的地址,因此共享库中的代码不能依赖特定的加载地址(或位置)。作为程序员,这并不需要你自己操心;你只需要在编译这些用于共享库的对象文件的时候,在编译器参数中指明–fPIC。

>    假设系统中同时有 libtest.a 和 libtest.so。这时链接器必须从两者中选择一个进行链接。链接器会依次搜索每个文件夹(首先搜索 –L 选项指定的路径,然后是系统默认搜索路径)。不论链接器发现了哪一个,它都会停止搜索过程。如果当时只找到了两者中的一个,链接器会选择找到的那个进行链接。如果两个版本同时存在,除非你明确指定链接静态版本,链接器会选择共享库版本进行链接。对链接器指定 –static 选项表示你希望使用静态版本。
>  例如,当使用下面的命令进行链接的时候,即使 libtest.so 同时存在,链接器仍将选择 libtest.a 进行链接:
            % gcc –static –o app app.o –L. –ltest
可以用 ldd 命令显示与一个程序建立了动态链接的库的列表。当程序运行的时候,这些库必须存在系统中。注意 ldd 命令会输出一个特殊的叫做 ld-linux.so的库。	它是 GNU/Linux系统动态链接机制的组成部分。								

>>- 使用 LD_LIBRARY_PATH

>>当你将一个程序与共享库进行动态链接的时候,链接器并不会将共享库的完整路径加入得到的执行文件中,而是只记录共享库的名字。当程序实际运行的时候,系统会搜索并加载这个共享库。

>>默认情况下,系统只搜索 /lib 和 /usr/lib。如果某个链接到程序中的共享库被安装在这些目录之外的地方,系统将无法找到这个共享库,并因此拒绝执行你的程序。
>>一种解决方法是在链接的时候指明 –Wl,-rpath 参数。假设你用下面的命令进行链接:  
    gcc –o app app.o –L. –ltest –Wl,-rpath,/usr/local/lib
>>另外一个解决方案是在运行程序的时候设置LD_LIBRARY_PATH环境变量。与PATH变量类似,LD_LIBRARY_PATH包含的是一组以冒号分割的目录列表。
>>例如,假设我们将 LD_LIBRARY_PATH设为 /usr/local/lib:/opt/lib,则系统会在搜索默认路径 /lib和/usr/lib之前搜索 /usr/local/lib 和 /opt/lib目录 。 需要注意的是 , 如果在编译程序的时候设定 LD_LIBRARY_PATH环境变量,链接器会在搜索 –L参数指定的路径之前搜索这个环境变量中指定的路径以寻找库文件。

>- 标准库

>即使你在程序链接阶段并没有指明任何库,几乎可以确信程序总会链接到某些共享库中。这是因为 GCC 会自动将程序链接到标准 C 库 libc。标准 C 库的数学函数并未被包含在 libc 中;它们位于 libm 中,而这个库要求你明确指定才会链接到程序中。

>- 库依赖性
										
 > 经常出现这样的情况:一个库依赖另一个库。例如,许多 GNU/Linux 系统提供了 libtiff,一个包含了读写 TIFF 格式图片的函数的库。这个库依次依赖 libjpeg(JPEG 图像函数库)和 libz(压缩函数库).而另一方面,静态库无法指向其它的库。有时候,两个库可能互相依赖。也就是说,第一个库可能引用了第二个库中定义的符号,反之亦然。通常这种情况都是由于不良设计导致的;但是这种情况确实可能出现。在这种情况下,你可以在命令行中多次指定同一个库。链接器会在每次读取到这个库的时候重新查找库中的符号。	

>- 优点与缺陷		

>动态库的重要优点之一在于,为安装程序的系统节省了空间。假设你安装了 10 个程序,而它们同时会利用同一个库,则使用共享库较之使用静态库将为系统节省大量的空间。如果你选用静态库,则你将会在系统中随这十个程序保存十份静态库的副本。因此,使用共享库可以节省磁盘空间。而且如果你的程序是从网络上下载的,使用共享库可以同时节省下载时间。

>共享库与此相关的一个优势在于,程序员可以选择升级这个库而不必强令用户同时升级所有依赖这个库的程序。例如,假设你写了一个用于处理 HTTP 连接的库。可能有许多程序依赖这个库。如果你在库的代码中发现了 bug,你可以选择升级你的库。与此同时,所有使用这个库的程序中的 bug 都会被修复;你不必像使用静态库那样重新链接所有这些程序。

>但是,仍然存在一些现实的理由让程序选择链接到静态库。升级共享库同时会升级所有依赖程序的特点很可能成为一个缺陷。假设你开发了一个用于处理关键性任务的程序,你可能应该选择静态链接你的程序以防止对系统的升级影响到你的程序的运行。(否则,也许用户会升级系统中的共享库,由此影响到你程序的运行,然后打电话到你的技术支持热线并责怪你的程序的错误。)	

>如果你可能没有将库安装到 /lib 或 /usr/lib 的权限,你绝对应该重新考虑是否将你的库作为共享库发布。(除非你要求你的用户具有管理员权限,你的库将无法被安装到 /lib 或/usr/lib 目录。)而且,如果你不确定库最终被安装的位置,-Wl,rpath 的办法也无法起作用。让你的用户去设置 LD_LIBRARY_PATH 对他们而言意味着额外的步骤。因为每个用户都必须为自己设置这个环境变量,这将着实成为一个负担。每当你尝试发布一个程序的时候,你都不得不对这些有缺点进行权重并选择合适的形式发布你的程序。

>- 动态加载与卸载

>在 Linux 系统中,这种功能可以通过使用 dlopen 函数获取。你可以这样通过 dlopen 加载一个名为 dlopen 的函数:
dlopen (“libtest.so”, RTLD_LAZY);
>(第二个参数是一个标志,它指明了绑定库中符号的方法。你可以参考 dlopen 的手册页以获取更详细的信息,不过 RTLD_LAZY 通常就是你所需要的。)
>如果使用动态加载函数,需要在程序文件中包含 < dlfcn.h> 头文件,并将程序链接到 libdl 库(通过为编译器指定 –ldl 参数)。这个函数会返回一个 void *指针;这个指针将被用作一个操作被加载的共享库的句柄。你可以将这个指针传递给 dlsym 函数以获取被加载的库中特定函数的地址。假设 libtest.so中定义了一个函数 my_function,则你可以这样调用这个函数.
void* handle = dlopen (“libtest.so”, RTLD_LAZY);
void (*test)() = dlsym (handle, “my_function”);
(*test)();
dlclose (handle);
>这里,系统调用 dlsym 还可以用于从共享库中获取静态变量的地址。

>前面提到的两个函数,dlopen 和 dlsym,均会在执行失败的时候返回NULL。这时你可以调用dlerror(不需指定任何参数)获取一个可读的信息对出现的错误进行解释。函数 dlclose 可以从内存中卸载已经加载的库。技术上来说,dlopen 只在库并未被加载的情况下将共享库载入内存;如果这个库已被加载,则 dlopen 仅增加指向这个库的引用计数。同样的,dlclose 只是将库的引用计数减一;只有当引用计数到达 0 的时候这个函数才会真正地将库卸载。

>如果你的共享库是用 C++ 语言写成,则你需要将那些用于提供外界访问的函数和变量用 extern “C” 链接修饰符进行修饰。假设你的共享库中有一个 C++ 函数 foo,而你希望通过 dlsym 访问这个函数,你需要这样对它进行声明:
extern “C” void foo ();
>这样就可以防止 C++ 编译器对函数名称进行修饰。否则,C++ 编译器可能将函数名从foo 变为另外一个看起来很可笑的名字;这个名字中包含了其它一些与这个函数相关的信息。C 编译器不会对标识符进行修饰;它会直接使用任何你指定的函数或变量名。


#进程

一个程序的一份运行中的实例叫做一个进程。如果你屏幕上显示了两个终端窗口,你很可能同时将一个终端程序运行了两次——你有两个终端窗口进程。每个窗口可能都运行着一个 shell;每个运行中的 shell 都是一个单独的进程。当你从一个 shell 里面调用一个程序的时候,对应的程序在一个新进程中运行;运行结束后 shell 继续工作。
高级程序员经常在一个应用程序中同时启用多个协作的进程以使程序可以并行更多任务、使程序更健壮,或者可以直接利用已有的其它程序.


- 查看进程

>- 进程 ID

>   Linux 系统中的每个进程都由一个独一无二的进程 ID(通常也被称为 pid)标识。进程 ID 是一个 16 位的数字,由 Linux 在创建新进程的时候自动依次分配。
每个进程都有一个父进程(除了“僵尸进程”中介绍的特殊的 init 进程)。
因此,你可以把 Linux 中的进程结构想象成一个树状结构,其中 init 进程就是树的“根”。父进程 ID ( ppid ) 就是当前进程的父进程的 ID。当需要从 C 或 C++程序中使用进程 ID 的时候,应该始终使用< sys/types.h>中定义的pid_t 类型。程序可以通过 getpid()系统调用获取自身所运行的进程的 ID,也可以通过getppid()系统调用获取父进程 ID。

>- 查看活动进程

>   运行 ps 命令可以显示当前系统中运行的进程。 GNU/Linux 版本的 ps 有很多选项,因为它试图与很多不同 UNIX 版本的 ps 命令兼容。这些选项决定显示哪些进程以及要显示的信息。默认情况下,调用 ps 会显示当前调用 ps 命令的终端或终端窗口所控制的所有进程的相关信息。可以利用下面这个命令来仔细的研究你的 GNU/Linux 系统中运行了什么:
% ps -e -o pid,ppid,command
>这里-e 选项让 ps 命令显示系统中运行的所有进程的信息。而-o pid,ppid,command 选项告诉 ps 要显示每个进程的哪些信息——这里,我们让 ps 显示进程 ID、父进程 ID 以及进程运行的命令行。

>>ps 输出格式

 >> 当在调用 ps 时附加了-o 选项,你可以用一个逗号分割的列表指定你需要显示的进程信息。例如, 
 >ps -o pid,user,start_time,command 会显示进程 ID,运行该进程的用户名,进程开始的时间(wall clock time,墙面钟时间),以及进程运行的命令。

>- 中止一个进程
>
>  你可以用 kill 命令中止一个正在运行的进程。只要将需要中止的进程 ID 作为命令行参数调用 kill 就可以。kill 命令通过对目标进程发送SIGTERM(中止) 信号来中止目标进程。在这个程序没有显式处理或忽略了SIGTERM信号的情况下,这会导致目标进程被终止。

- 创建进程

通常有两种方法可以创建进程。第一种方法相对简单,但是在使用之前应慎重考虑,因为它效率低下,而且具有不容忽视的安全风险。第二种方法相对复杂了很多,但是提供了更好的弹性、效率和安全性。

>- 使用 system

>C 标准库中的 system 函数提供了一种调用其它程序的简单方法。利用 system 函数调用程序结果与从 shell 中执行这个程序基本相似。事实上,system 建立了一个运行着标准Bourne shell(/bin/sh)的子进程,然后将命令交由它执行。

>调用 system 函数的返回值就是被调用的 shell 命令的返回值。如果 shell 自身无法运行,system 函数返回 127;如果出现了其它错误,system 返回 -1。因为 system 函数使用 shell 调用命令,它受到系统 shell 自身的功能特性和安全缺陷的限制。你不应该试图依赖于任何特定版本的 Bourne shell。许多 UNIX 系统中, /bin/sh 是一个指向其它 shell 的符号链接。
>例如,在绝大多数 GNU/Linux 系统中, /bin/sh 指向 
>bash(Bourne-Again SHell),并且不同的 Linux 系统使用不同版本的 bash。例如,以 root 权限通过 system 调用一个程序,在不同的 Linux 系统中可能得到不同结果。因此, fork 和exec 才是推荐用于创建进程的方法。		

>- 使用 fork 和 exec
>
>DOS 和 Windows API 都包含了 spawn 系列函数。这些函数接收一个要运行的程序名作为参数,启动一个新进程中运行它。Linux 没有这样一个系统调用可以在一个步骤中完成这些。相应的,Linux 提供了一个 fork 函数,创建一个调用进程的精确拷贝。Linux同时提供了另外一系列函数,被称为 exec 族函数,使一个进程由运行一个程序的实例转换到运行另外一个程序的实例。要产生一个新进程,应首先用 fork 创建一个当前进程的副本,然后使用 exec 将其中一个进程转为运行新的程序。

>>- 调用 fork

>>  一个进程通过调用 fork 会创建一个被称为 子进程 的副本进程。父进程从调用 fork 的地方继续执行;子进程也一样。首先,子进程是一个新建立的进程,因此有一个与父进程不同的进程ID。因此可以通过调用 getpid 检测自身运行在子进程还是父进程。不过,fork 函数对父子进程提供了不同的返回值——一个进程“进入”fork 调用,而另外一个则从调用中“出来”。**父进程得到的 fork 调用返回值是子进程的 ID。子进程得到的返回值是 0。**因为任何进程的 ID 均不为 0,程序可以藉此很轻松的判断自身运行在哪个进程中.

>>- 调用 exec 族函数

>>  Exec 族函数用一个程序替换当前进程中正在运行的程序。当某个 exec 族的函数被调用时,如果没有出现错误的话,调用程序会被立刻中止,而新的程序则从头开始运行。Exec 族函数在名字和作用方面有细微的差别。

>>>- 名称包含 p 字母的函数(execvp 和 execlp)接受一个程序名作为参数,然后在当前的执行路径(译者注:环境变量 PATH 指明的路径)中搜索并执行这个程序;名字不包含 p 字母的函数在调用时必须指定程序的完整路径。

>>>- 名称包含 l 字母的函数(execl、execlp 和 execle)接收一个字符串数组作为调用程序的参数;这个数组必须以一个 NULL 指针作为结束的标志。名字包含 v 字母的函数(execv, execvp 和 execve)以 C 语言中的 vargs (译者注:原文为 varargs,疑为笔误)形式接受参数列表.

>>>- 名称包含e字母的函数(execve 和 execle)比其它版本多接收一个指明了环境变量列表的参数。这个参数的格式应为一个以 NULL 指针作为结束标记的字符串数组。每个字符串应该表示为“变量=值”的形式。

>>因为 exec 会用新程序代替当前程序,除非出现错误,否则它不会返回。传递给程序的参数列表和当你从 shell 运行时传递给程序的命令行参数相似。新程序可以从 main 函数的 argc 和 argv 参数中获取它们。

>>请记住,当一个程序是从 shell 中被调用的时候,shell 程序会将第一个参数(argv[0])设为程序的名称,第二个参数(argv[1])为第一个命令行参数,依此类推。当你在自己的程序中使用 exec 函数的时候,也应该将程序名称作为第一个参数传递进去。

>>- 将 fork 和 exec 结合使用

>>运行一个子程序的最常见办法是先用 fork 创建现有进程的副本,然后在得到的子进程中用 exec 运行新程序。这样在保持原程序继续运行的同时,在子进程中开始运行新的程序。

>- 进程调度

> Linux 会分别独立地调度父子进程;不保证进程被调度的先后顺序,也不保证被调度的进程在被另外一个(或系统中其它进程)打断之前会运行多久。具体来说,ls命令也许在父进程结束之前根本没有被调度运行,也可能是ls命令运行了一部分或者全部完成之后主进程才结束执行 。 Linux保证每个程序都会得到运行——不会有某个进程因为缺乏资源而无法运行。

>你可以将一个进程标记为次要的;给进程指定一个较高的 niceness 值会给这个进程分配较低的优先级。默认情况下,每个进程的 niceness 均为 0。较高的 niceness 值代表了较低的进程优先级;相应的,较低的niceness 值(负值)表示较高的进程优先级。

>使用 nice 命令的-n 参数允许用户以一个指定的 niceness 值运行特定程序。例如,要执行“ sort input.txt > output.txt ”这个会执行较长时间的排序命令,可以通过下面的命令降低它的优先级,使它不会过度地影响系统的运行: 
> % nice -n 10 sort input.txt > output.txt

>你可以使用 renice 命令从命令行调整一个正在运行的程序的 niceness 值。可以通过调用 nice 函数以编程的方法调整一个运行中的进程的优先级。它的参数会被加在调用进程的 niceness 值上。记住,大于 0 的值会提高进程的 niceness 值,从而降低进程优先级。

>需要注意的是,只有当一个进程以 root 权限运行的时候才能以负的 niceness 值运行其它程序,或降低一个进程的 niceness 值。这表明,只有当你以 root 身份登陆的时候,你才可以用负数做参数调用 nice 和 renice 命令,而只有当一个进程以 root 身份运行的时候才可以以负值作参数调用 nice 函数。这种限制可以防止普通用户从其它用户的手中夺取程序运行优先级。			

- 信号

信号( Signal ) 是 Linux 系统中用于进程之间相互通信或操作的一种机制。信号是一个相当广泛的课题;在这里,我们仅仅探讨几种最重要的信号以及利用信号控制进程的技术。

信号是一个发送到进程的特殊信息。信号机制是异步的;当一个进程接收到一个信号时,会立刻处理这个信号,而不会等待当前函数甚至当前一行代码结束运行。信号有几十种,分别代表着不同的意义。信号之间依靠它们的值来区分,但是通常在程序中使用信号的名字来表示一个信号。

在 Linux 系统中,这些信号和以它们的名称命名的常量均定义在/usr/include/bits/signum.h 文件中。(通常程序中不需要直接包含这个头文件,而应该包含< signal.h>。)	

当一个进程接收到信号,基于不同的 处理方式(disposition ),该进程可能执行几种不同操作中的一种。每个信号都有一个默认处理方式 (default disposition),当进程没有指定自己对于某个信号的处理方式的时候,默认处理方式将被用于对对应信号作出响应。对于多数种类的信号,程序都可以自由指定一个处理方式——程序可以选择忽略这个信号,或者调用一个特定的信号处理函数。如果指定了一个信号处理函数,当前程序会暂停当前的执行过程,同时开始执行信号处理函数,并且当信号处理函数返回之后再从被暂停处继续执行。

Linux 系统在运行中出现特殊状况的时候也会向进程发送信号通知。				

一个进程除了响应系统发来的信号,还可以向其它进程发送信号。对于这种机制的一个最常见的应用就是通过发送SIGTERM或SIGKILL信号来结束其它进程.除此之外,它还常见于向运行中的进程发送命令。两个“用户自定义”的信号SIGUSR1 和SIGUSR2 就是专门作此用途的。 SIGHUP信号有时也用于这个目的——通常用于唤醒一个处于等待状态的进程或者使进程重新读取配置文件。

>SIGTERM 信号要求进程中止;进程可以修改请求或者直接忽略这个信号。SIGKILL 信号会立即中止进程,因为进程无法忽略或修改对 SIGKILL 信号的响应。

 系统调用 sigaction 用于指定信号的处理方式。函数的第一个参数是信号的值。之后两 个参数是两个指向 sigaction 结构的指针;第一个指向了将被设置的处理方式,第二个用于保存先前的处理方式。这两个 sigaction 结构中最重要的都是 sa_handler 域。

 >它可以是下面三个值:

>-  SIG_DFL,指定默认的信号处理方式
>- SIG_IGN,指定该信号将被忽略
>- 一个指向信号处理函数的指针。这个函数应该接受信号值作为唯一参数,且没有返回值。因为信号处理是异步进行的,当信号处理函数被调用的时候,主程序可能处在非常脆弱的状态,并且这个状态会一直保持到信号处理函数结束。因此,应该尽量避免在信号处理函数中使用输入输出功能、绝大多数库函数和系统调用。信号处理函数应该做尽可能少的工作以响应信号的到达,然后返回到主程序中继续运行(或者结束进程)。多数情况下,所进行的工作只是记录信号的到达。而主程序则定期检查是否有信号到达,并且针对当时情况作出相应的处理。

信号处理函数也可能被其它信号的到达所打断。虽然这种情况听起来非常罕见,一旦出现,程序将非常难以确定问题并进行调试。	因此,对于你的信号处理函数进行哪些工作一定要进行慎重的考虑。		
							
甚至于对全局变量赋值可能也是不安全的,因为一个赋值操作可能由两个或更多机器指令完成,而在这些指令执行期间可能会有第二个信号到达,致使被修改的全局变量处于不完整的状态。如果你需要从信号处理函数中设置全局标志以记录信号的到达,这个标志必须是特殊类型 sig_atomic_t 的实例。Linux 保证对于这个类型变量的赋值操作只需要一条机器指令,因此不用担心可能在中途被打断。

在 Linux 系统中,sig_atomic_t 就是基本的 int 类型;事实上,对 int 或者更小的整型变量以及指针赋值的操作都是原子操作。不过,如果你希望所写的程序可以向任何标准 UNIX 系统移植,则应将所有全局变量设为sig_atomic_t 类型。
							
- 进程终止			

通常,进程会以两种情况的之一结束:调用 exit 函数退出或从 main 函数返回。每个进程都有退出值(exit code):一个返回给父进程的数字。一个进程退出值就是程序调用 exit函数的参数,或者 main 函数的返回值。

进程也可能由于信号的出现而异常结束。例如,之前提到的SIGBUS,SIGSEGV 和SIGFPE 信号的出现会导致进程结束。其它信号也可能显式结束进程。

当用户在终端按下Ctrl+C 时会发送一个 SIGINT 信号给进程。SIGTERM 信号由 kill 命令发送。这两个信号的默认处理方式都是结束进程。进程通过调用 abort 函数给自己发送一个 SIGABRT 信号,导致自身中止运行并且产生一个 core file。最强有力的终止信号是 SIGKILL,它会导致进程立刻终止,而且这个信号无法被阻止或被程序自主处理。这里任何一个信号都可以通过指定一个特殊选项,由 kill 命令发送;

要从程序中发送信号,使用 kill 函数。第一个参数是目标进程号。第二个参数是要发送的信号;传递 SIGTERM 可以模拟 kill 命令的默认行为。例如,你可以利用 kill 函数,像这样从父进程中结束子进程的运行(这里 child_pid 包含的是子进程的进程号)
      kill (child_pid, SIGTERM);
需要包含< sys/types.h>和< signal.h>头文件才能在程序中调用 kill 函数。

根据习惯,程序的退出代码可用来确认程序是否正常运行。返回值为0表示程序正确运行,而非零的返回值表示运行过程出现错误。在后一种情况下,返回值可能表示了特定的错误含义。通常应该遵守这个约定,因为 GNU/Linux 系统的其它组件会假设程序遵循这个行为模式。例如,当使用 &&(逻辑与)或 ||(逻辑或)连接多个程序的时候,shell 根据这个假定判断逻辑运算的结果。因此,除非有错误发生,你都应该在 main 结束的时候明确地返回 0。

对于多数 shell 程序,最后运行的程序的返回值都保存在特殊环境变量$?中。需要注意的是,尽管 exit 函数的参数类型是 int ,而 main 函数返回值也是 int 类型,Linux 不会为返回值保留 32 位长度。实际上,你应该只使用 0 到 127 之间的数值作为退出代码。大于 128 的退出代码有特殊的含义——当一个进程由于一个信号而结束运行,它的退出值就是 128 加上信号的值。

>- 等待进程结束

>在某些情况下,主程序可能希望暂停运行以等待子进程完成任务。可以通过 wait族系统调用实现这一功能。这些函数允许你等待一个进程结束运行,并且允许父进程得到子进程结束的信息。 Wait 族系统调用一共有四个函数;通过选择不同的版本,你可以选择从退出进程得到信息的多少,也可以选择关注某个特定子进程的退出。

>- wait 系统调用

>一族函数中,最简单的是 wait 。它会阻塞调用进程,直到某一个子进程退出(或者出现一个错误)。它通过一个传入的整型指针参数返回一个状态码,从而可以得到子进程的退出信息。例如,WEXITSTATUS 宏可以提取子进程的退出值。你可以用 WIFEXITED 宏从一个子进程的返回状态中检测该进程是正常结束(利用exit 函数或者从 main 函数返回)还是被没有处理的信号异常终止。对于后一种情况,可以用 WTERMSIG 宏从中得到结束该进程的信号。

>- 僵尸进程

>如果一个子进程结束的时候,它的父进程正在调用 wait 函数,子进程会直接消失,而退出代码则通过 wait 函数传递给父进程。但是,如果子进程结束的时候,父进程并没有调用 wait,则又会发生什么?它是不是简单地就消失了呢?不,因为如果这样,它退出时返回的相关信息——譬如它是否正常结束,以及它的退出值——会直接丢失掉。在这种情况下,子进程死亡的时候会转化为一个僵尸进程。

 >  一个僵尸进程是一个已经中止而没有被清理的进程。清理僵尸子进程是父进程的责任。Wait 函数会负责这个清理过程,所以你不必在等待一个子进程之前检测它是否正在运行。

>  假设,一个进程创建了一个子进程,进行了另外一些计算,然后调用了wait 。如果子进程还没有结束,这个进程会在 wait 调用中阻塞,直到子进程结束。如果子进程在父进程调用wait 之前结束,子进程会变成一个僵尸进程。当父进程调用 wait ,僵尸子进程的结束状态被提取出来,子进程被删除,并且 wait 函数立刻返回。如果父进程不清理子进程会如何?它们会作为僵尸进程,一直被保留在系统中。

>  当一个程序退出,它的子进程被一个特殊进程继承,这就是 init 进程。 Init 进程总以进程 ID 1 运行(它是 Linux 启动后运行的第一个进程)。 Init 进程会自动清理所有它继承的僵尸进程。

>- 异步清理子进程
>
>如果你创建一个子进程只是简单的调用 exec 运行其它程序,在父进程中立刻调用 wait 进行等待并没有什么问题,只是会导致父进程阻塞等待子进程结束。但是,很多时候你希望在子进程运行的同时,父进程继续并行运行。怎么才能保证能清理已经结束运行的子进程而不留下任何僵尸进程在系统中浪费资源呢?

>  一种解决方法是让父进程定期调用 wait3 或 wait4 以清理僵尸子进程。在这种情况调用 wait 并不合适,因为如果没有子进程结束,这个调用会阻塞直到子进程结束为止。然而,你可以传递 WNOHANG 标志给 wait3 或 wait4 函数作为一个额外的参数。如果设定了这个标志,这两个函数将会以非阻塞模式运行——如果有结束的子进程,它们会进行清理;否则会立刻返回。第一种情况下返回值是结束的子进程 ID,否则返回 0。

>另外一种更漂亮的解决方法是当一个子进程结束的时候通知父进程。有很多途径可以做到这一点;不过幸运的是 Linux 利用信号机制完成了这些。当一个子进程结束的时候,Linux给父进程发送 SIGCHLD 信号。这个信号的默认处理方式是什么都不做;这也许是为什么之前你忽略了它的原因。

>因此,一个简单的清理结束运行的子进程的方法是响应 SIGCHLD 信号。当然,当清理子进程的时候,如果需要相关信息,一个很重要的工作就是保存进程退出状态,因为一旦用 wait 清理了进程,就再也无法得到这些信息了。

>**注意信号处理函数中将进程退出代码保存到了全局变量中,从而可以在主程序中访问它。因为这个变量在信号处理函数中被赋值,我们将它声明为 sig_atomic_t 类型。**

# 线程


 线程,不同于进程,是一种允许一个程序同时执行不止一个任务的机制。与进程相似,不同线程看起来是并行运行的;Linux 核心对它们进行异步调度,不断中断它们的执行以给其它线程执行的机会。

 概念上,线程出现在进程中。相比进程,线程是一种更细粒度的执行单元。当你调用一个程序,Linux 创建一个新进程,并且在那个新进程中创建一个线程;这个线程依序执行程序。这个线程可以创建更多的线程;所有这些线程在同一个进程中执行同一个程序,但是每个线程在特定时间点上可能分别执行这个程序的不同部分。

子进程开始时候运行父进程的程序,并且从父进程处复制了虚拟内存、文件描述符和其它信息。子进程可以修改自己的内存、关闭文件描述符、执行其它各种操作,但是这些操作不会影响父进程;反之亦然。不过,当一个程序创建了一个线程时并不会复制任何东西。创建和被创建的线程同先前一样共享内存空间、文件描述符和其它各种系统资源。

GNU/Linux 实现了 POSIX 标准线程 API(所谓 pthreads)。所有线程函数和数据类型都在 < pthread.h> 头文件中声明。这些线程相关的函数没有被包含在 C 标准库中,而是在libpthread 中,所以当链接程序的时候需在命令行中加入 -lpthread 以确保能正确链接。

- 创建线程

创建线程时,每个线程都开始执行一个 线程函数 。这只是一个普通的函数,包含了线程应执行的代码;当函数返回的时候,线程也随之结束。在 GNU/Linux 系统中,线程函数接受一个 void* 类型的参数,并且返回 void* 类型。这个参数(parameter)被称为 线程参数( thread argument ) :GNU/Linux 系统不经查看直接将它传递给线程。你的程序可以利用这个参数给新线程传递数据。相似的,你的线程可以利用返回值给它的创建者线程返回数据。

>   函数 pthread_create 负责创建新线程。你需要给它提供如下信息:

>>- 一个指向 pthread_t 类型变量的指针;新线程的线程 ID 将存储在这里。
>>- 一个指向 线程属性( thread attribute ) 对象的指针。这个对象控制着新线程与程序其它部分交互的具体细节。如果传递 NULL 作为线程属性,新线程将被赋予一组默认线程属性。
>>- 一个指向线程函数的指针。这是一个普通的函数指针,类型如下:         void* (*) (void*)
>>- 一个线程参数,类型 void*。不论你传递什么值作为这个参数,当线程开始执行的时候,它都会被直接传递给新的线程。

>    函数 pthread_create 会在调用后立刻返回,原线程会继续执行之后 的指令。同时,新程开始执行线程函数。Linux 异步调度这两个线程,因此你的程序不能依赖两个线程得到行的特定先后顺序。

>在一般状况下,一个线程有两种退出方式。一种方式,如先前所示,是从线程函数中返回以退出线程。线程函数的返回值也被作为线程的返回值。另一种方式则是线程显式调用pthread_exit。这个函数可以直接在线程函数中调用,也可以在其它直接、间接被线程函数调用的函数中调用。调用 pthread_exit 的参数就是线程的返回值。

>- 给线程传递数据

>  线程参数提供了一种为新创建的线程传递数据的简便方式。因为参数是 void*,你无法通过参数本身直接传递大量数据,而应使用线程参数传递一个指向某个数据结构或数组的指针。一个常用的技巧是给线程函数定义一个结构以包含线程函数所期待的实际参数序列。利用线程参数可以很轻易地重用一个线程函数创建许多线程。所有这些线程可以针对不同的数据执行相同的操作。

>- 等待线程 (原文:Joining Threads) 

>  我们需要一个类似 wait 的函数,但是等待的是线程而不是进程。这个函数是 pthread_join。它接受两个参数:线程 ID,和一个指向 void*类型变量的指针,用于接收线程的返回值。如果你对线程的返回值不感兴趣,则将 NULL 作为第二个参数。

>  一旦你将对某个数据变量的引用传递给某个线程,务必确保这个变量在不会被释放(甚至在其它线程中也不行!),直到你确定这个线程不会再使用它。这对于局部变量(当生命期结束的时候自动释放)和堆上分配的对象(通过 free 或者 C++的 delete手工释放)同样适用。

>- 线程返回值

>  如果传递给pthread_join的第二个参数不是 NULL,则线程返回值会被存储在这个指针指向的内存空间中。线程返回值,与线程变量一样,也是void*类型。如果你想要返回一个int或者其它小数字,你可以简单地把这个数值强制转换成void*指针并返回,并且在调用pthread_join之后把得到的结果转换回相应的类型.

>- 关于线程 ID 的更多信息

>  有时候,一段代码需要确定是哪个线程正在执行到这里。可以通过 pthread_self 函数获取调用线程 ID。所得到的线程 ID 可以用pthread_equal 函数与其它线程 ID 进行比较。这些函数可以用于检测当前线程 ID 是否为一特定线程 ID。例如,一个线程利用pthread_join 等待自身是错误的。(在这种情况下, pthread_join 会返回错误码 EDEADLK。)

>- 线程属性

>  线程属性提供了一种可以用于在细粒度调整线程行为方式的机制。试着回忆一下,pthread_create 函数接受一个指向线程属性对象的指针。如果你传递 NULL 指针,默认线程属性被用于配置新线程。同时,你也可以通过创建并且传递一个线程属性对象来指明属性中的一些值。

>>要指明自定义的线程属性,你必须参照以下步骤:

>>- 创建一个 pthread_attr_t 对象。最简单的方法是声明一个该类型的自动变量。
>>- 调用 pthread_attr_init,传递一个指向新创建对象的指针。这个步骤将各个属性置为默认值。
>>- 修改这个对象,使各个属性包含期望的值。
>>- 在调用 pthread_create 的时候,传递一个指向该对象的指针。
>>- 调用 pthread_attr_destroy 释放这个属性对象。这个 pthread_attr_t 对象本身不会被释放;可以通过 pthread_attr_init 将其重新初始化。

>  一个单独线程对象可以用于创建许多线程。在创建线程之后没有必要保持线程属性对象。

>对于多数 GNU/Linux 应用程序而言,一般只有一个线程属性会显得有趣(其它的主要属性均针对实时程序)。这个属性就是线程的脱离状态(detach state ) 。

>一个线程可以创建为一个可等待线程( joinable thread ) (默认情况)或者一个 脱离线程( detached thread ) 。一个可等待线程,类似一个进程,在结束的时候不会被 GNU/Linux 系统自动清理。相反的,它的退出状态停留在系统中(某种程度来说,类似一个僵尸进程)直到另外某个线程调用 pthread_join 获取它的返回值。直到这时,它的资源才被释放。

>与此不同的是,一个脱离线程在结束的时候会被自动清理。因为脱离线程会被立刻清理,其它线程无法与它的结束事件进行同步,也无法获取其返回值。

>可以使用 pthread_attr_setdetachstate 函数设置脱离属性。第一个参数是一个指向线程属性对象的指针,第二个参数是脱离状态。因为可等待状态是默认的,只有创建脱离线程的时候才需要调用这个函数;传递 PTHREAD__CREATE__DETACHED 作为第二个参数。

>即使一个线程是创建成为一个可等待线程,它也可以随后转换成一个脱离线程。调用pthread_detach 进行这个转换过程。一旦线程成为脱离线程,它将无法转换会可等待状态。

- 线程取消

一般情况下,一个线程在它正常结束(通过从线程函数返回或者调用 pthread_exit 退出)的时候终止。但是,一个线程可以请求另外一个线程中止。这被成为取消一个线程。

要取消一个线程,以被取消的线程ID作为参数调用 pthread_cancel。一个被取消的线程可以稍后被其它线程等待;实际上,你应该对一个被取消的线程执行 pthread_wait 以释放它占用的资源,除非这个线程是脱离线程.
一个取消线程的返回值由特殊值 PTHREAD_CANCELED 指定。

经常,线程可能运行在一段不可分割的代码中,必须全部得到执行或者干脆不执行。例如,线程可能分配一些资源,使用并稍后释放它们。如果线程在中途被取消,它可能没有机会释放那些被分配的资源,从而导致资源的泄漏。为防止这种情况发生,一个线程可以控制自身是否可以被取消,以及何时允许取消操作。

>   对于线程取消而言,一个线程可能处于如下三种情况之一:
>>- 线程可以被异步取消( asynchronously cancelable )。线程可以在执行中的任意时刻被取消。
>>- 线程可以被同步取消( synchronously cancelable ) 。线程可以被取消,但是不是在任意时刻都可以。相反的,取消请求会被排队,而线程只有在到达特殊的执行点才会执行取消操作。
>>- 线程 不可被取消( uncancelable ) 。尝试取消线程的请求会被直接忽略。

>当一个线程刚被建立的时候,它处于可同步取消状态。

>- 同步和异步线程

>  一个可异步取消的线程可在它执行过程中的任意时刻被取消。一个可同步取消的线程,概念上来说,只能在执行过程中的特定位置被取消。这些位置被称为取消点( cancellation points ) 。线程会将取消请求排队,直到到达下一个取消点再由程序处理。可以通过调用pthread_setcanceltype 使一个线程进入允许被异步取消的状态。这个函数作用于调用它的线程。第一个参数可以是常量  :  PTHREAD_CANCEL_ASYNCHRONOUS,
表示将线程设置为可异步取消状态;或者是PTHREAD_CANCEL_DEFERRED,将线程设置回可同步取消状态。如果第二个参数不为空,则它指向的变量将保存线程的前一个取消类型。

>  取消点究竟是什么?它们应该被放置在哪里?最直接的创建一个取消点的方法是调用 pthread_testcancel。这个函数的唯一工作就是在一个可同步取消的线程中处理一个没有被处理的线程取消请求。如果一个线程要执行长时间的计算过程,则应该定期在线程取消不会导致资源泄露或产生其它负面影响的情况下调用 pthread_testcancel。还有部分函数可以作为隐式的取消点。在 pthread_cancel 的手册页中有这些函数的列表。需要注意的是,其它函数可能因为调用这些函数而间接成为取消点。

>- 不可取消的临界区

>  线程可以利用 pthread_setcancelstate 函数完全禁止自己被取消.类似于 pthread_setcanceltype,这个函数作用于调用线程。如果将PTHREAD_CANCEL_DISABLE作为第一个参数,则线程取消操作将被禁止;如果是 PTHREAD_CANCEL_ENABLE 则线程取消被重新允许。第二个参数如果不为空,则指向的变量将保存线程的前一个线程取消状态。

>  程序可以利用 pthread_setcancelstate 实现临界区。**临界区**指的是一段必须完整执行或者完全不执行的代码;换言之,一旦一个线程进入临界区,在到达临界区终点之前它将无法被取消。

>  注意在退出临界区的时候应恢复线程取消状态到进入临界区之前的状态,而不是无条件地将线程取消状态设置为  PTHREAD_CANCEL_ENABLE。这样可以使从一个临界区中调用 process_transaction 的情况安全不出错——在这种情况下,这个函数会将线程取消状态恢复到调用之前的状态。

>- 何时使用线程取消

>  通常来说,除非特殊情况,不应使用线程取消结束一个线程的执行。通常情况下,当需要线程退出的情况下通知线程然后等待线程自动退出才是更好的策略。

- 线程专有数据( Thread-Specific Data)

与进程不同,一个程序中的所有线程运行在同一个地址空间中。着表示如果一个线程修改了内存中的一个位置(例如,一个全局变量),则其它所有线程都会发现这个变化。因此多个线程可以同时操作同一块数据而不依赖进程间通信技术。尽管数据是共享的,每个线程都有单独的调用堆栈。因此每个线程都可以单独执行自己的代码,不加变化地调用子程序、从子程序返回。与在单线程程序中一样,每个线程每次调用子程序都会创造一组自己的局部变量;这些变量保存在线程自己的栈上。不过有时仍然需要将一个变量复制给每个线程一个副本。

 GNU/Linux 系统通过为每个线程提供一个 线程专有数据区( thread-specific data area ) 。当数据被存放在这个区域时会自动为每个线程创建一个副本;当一个线程修改自己的副本的时候并不会影响其它线程的副本。因为所有的线程共享一个地址空间,线程专有数据不能通过普通的内存地址引用进行访问。GNU/Linux 系统提供了一系列函数用于读取和设置线程专有数据的值。

 你想创建多少线程专有数据对象都可以;它们的类型都是 void*。每个数据对象都通过一个键值进行映射。要创建一个新键值从而为每个线 程新创建一个数据对象,调用pthread_key_create 函数。第一个参数是一个指向 pthread_key_t 类型变量的指针。新创建的键值将被保存在这个 变量中。随后,这个键值可以被任意线程用于访问对应数据对象的属于自己的副本。传递给 pthread_key_create 的第二个参数是一个清理函数,如果你在这里传递一个函数指针,则 GNU/Linux 系统将在线程退出的时候以这个键值对应的数据对象为参数自动调用这个清理函数。清理函数非常有用,因为即使当线程在任何一个非特定运行时刻被取消,这个线程函数也会被保证调用。如果对应的数据对象是一个空指针,清理函数将不会被调用。如果你不需要调用清理函数,你可以在这里传递空指针。

创建了键值之后,可以通过调用 pthread_setspecific 设定相应的线程专有数据值。第一个参数是键值,而第二个参数是一个指向要设置的数据的 void*指针。以键值为参数调用pthread_getspecific 可重新获取一个已经设置的线程专有数据。

 假设这样一种情况,你的程序将一个任务分解以供多个线程执行。为了进行审计,每个线程都将分配一个单独的日志文件,用于记录对应线程的任务完成进度。线程专有数据区是为每个单独线程保存对应的日志文件指针的最方便的地点。

>- 清理句柄

>  线程专有数据的清理函数可以很有效地防止在线程退出或被取消的时候出现资源泄漏的问题。不过在有些情况下,我们希望创建一个清理函数却不希望为每个线程创建一个线程专有数据对象。出于这种需求,GNU/Linux 提供了清理句柄。

>  清理句柄就是一个当线程退出时被自动调用的函数。清理句柄函数接受一个 void*类型的参数,且这个参数在注册清理句柄的时候被同时确定——这样就可以很方便地允许用同一个清理函数清理多份资源实例。

>  清理句柄是一个临时性的工具,只在当线程被取消或中途退出而不是正常结束运行的时候被调用。在一般情况下,程序应该显式释放分配的资源并清除已经设置的清理句柄。

>  通过提供两个参数(一个指向清理函数的函数指针和一个作为清理函数参数的 void*类型的值)调用 pthread_cleanup_push 可以创建一个清理句柄。对      pthread_cleanup_pus  的调用可以通过调用 pthread_cleanup_pop 进行平衡:pthread_cleanup_pop 会取消对一个句柄的注册。为简便操作起见,pthread_cleanup_pop 函数接受一个 int 类型的参数;如果这个参数为非零值,则在取消注册这个句柄的同时,清理句柄将被执行。

>- C++中的线程清理方法

>  C++程序员习惯于通过将清理代码包装在对象析构函数中以获得“免费”的资源清理。当由于当前块的结束或者由于 C++异常的抛出导致对象的生命期结束的时候, C++确保自动对象的析构函数(如果存在)会被自动调用。这对确保无论代码块如何结束均能调用清理代码块有很大的帮助。但是,如果一个线程运行中调用了pthread_exit, C++并不能保证线程的栈上所有自动对象的析构函数将被调用。不过可以通过一个很聪明的方法来获得这个保证:通过抛出一个特别设计的异常,然后在顶层的栈框架内再调用 pthread_exit 退出线程。

- 同步和临界代码段

 使用线程编程可能需要非常高的技巧,因为多线程程序大多也是并行程序。在这种情况下程序员无从确认系统调度两个线程所采用的特定顺序。有时可能某个线程会连续运行很长时间,但系统也可能在几个线程之间飞快地来回切换。在一个多处理器系统中,几个线程可能如“并行”字面所示,在不同处理器上同时运行。

 调试多线程程序可能很困难,因为你可能无法轻易重现导致 bug 出现的情况。可能你某一次运行程序的时候一切正常,而下一次运行的时候却发现程序崩溃。没有办法让系统完全按照完全相同的次序调度这些线程。导致多线程程序出现 bug 的最根本原因是不同线程访问相同的数据。

 如前所示例,这是线程最强大的一个特征,但同时也是一个非常危险的特征。如果当一个线程正在更新一个数据的过程中另外一个线程访问同一个数据,很可能导致混乱的出现。很多有 bug 的多线程程序中包含一些代码要求某个线程比另外的线程更经常——或更快——被调用才能正常工作。这种 bug 被称为“竞争状态”;不同线程在更新一个数据结构的过程中出现相互竞争。

>- 竞争状态

>  假设你的程序利用一些线程并行处理一个队列中的任务。这个队列用一个 struct job 对象组成的链表来表示。每当一个线程结束操作,它都将检查队列中是否有等待处理的任务。如果 job_queue 不为空,这个线程将从链表中移除第一个对象,然后把 job_queue 指向链表中的下一个对象。

>  要消灭竞争状态,你需要通过某种方法使操作具有原子性。一个原子操作是不可分割不可中断的单一操作;一旦这个操作过程开始,在结束之前将无法被暂停或中断,也不会有其它的操作同时进行。在这个特定的例子中,你需要将“检查 job_queue;如果它不为空,删除第一个任务”整个过程作为一个原子操作。

>- 互斥体

>  当一个线程开始检查任务队列的时候,其它线程应该等待直到第一个线程决定是否处理任务,并在确定要处理任务时删除了相应任务之后才能访问任务队列。要实现等待这个操作需要操作系统的支持。GNU/Linux 提供了互斥体(mutex ,全称 MUTual EXclusion locks ,互斥锁 )。互斥体是一种特殊的锁:同一时刻只有一个线程可以锁定它。当一个锁被某个线程锁定的时候,如果有另外一个线程尝试锁定这个互斥体,则这第二个线程会被阻塞,或者说被置于等待状态。只有当第一个线程释放了对互斥体的锁定,第二个线程才能从阻塞状态恢复运行。

>  GNU/Linux 保证当多个线程同时锁定一个互斥体的时候不会产生竞争状态;只有一个线程可能成功锁定,其它线程均将被阻塞。

>  要创建一个互斥体,首先需要创建一个 pthread_mutex_t 类型的变量,并将一个指向这个变量的指针作为参数调用 pthread_mutex_init。而 pthread_mutex_init 的第二个参数是一个指向互斥体属性对象的指针;这个对象决定了新创建的互斥体的属性。与 pthread_create 一样,如果属性对象指针为 NULL,则默认属性将被赋予新建的互斥体对象。这个互斥体变量只应被初始化一次。

>  另外一个相对简单的方法是用特殊值PTHREAD_MUTEX_INITIALIZER 对互斥体变量进行初始化。这样就不必再调用 pthread_mutex_init 进行初始化。这对于全局变量(及 C++中的静态成员变量)的初始化非常有用。

>  线程可以通过调用 pthread_mutex_lock 尝试锁定一个互斥体。如果这个互斥体没有被锁定,则这个函数调用会锁定它然后立即返回。如果这个互斥体已经被另一个线程锁定,则 pthread_mutex_lock 会阻塞调用线程的运行,直到持有锁的线程解除了锁定。

>  同一时间可以有多个线程在一个互斥体上阻塞。当这个互斥体被解锁,只有一个线程(以不可预知的方式被选定的)会恢复执行并锁定互斥体,其它线程仍将处于锁定状态。调用 pthread_mutex_unlock 将解除对一个互斥体的锁定。始终应该从锁定了互斥体的线程调用这个函数进行解锁。

>- 互斥体死锁

>  互斥体提供了一种由一个线程阻止另一个线程执行的机制。这个机制导致了另外一类软件错误的产生:死锁。当一个或多个线程处于等待一个不可能出现的情况的状态的时候,我们称之为**死锁状态**。

>>  最简单的死锁可能出现在一个线程尝试锁定一个互斥体两次的时候。当这种情况出现的时候,程序的行为取决于所使用的互斥体的种类。共有三种互斥体:

>>- 锁定一个快速互斥体(fast mutex,默认创建的种类)会导致死锁的出现。任何对锁定互斥体的尝试都会被阻塞直到该互斥体被解锁的时候为止。但是因为锁定该互斥体的线程在同一个互斥体上被锁定,它永远无法接触互斥体上的锁定。
>>- 锁定一个递归互斥体(recursive mutex)不会导致死锁。递归互斥体可以很安全地被锁定多次。递归互斥体会记住持有锁的线程调用了多少次 pthread_mutex_lock;持有锁的线程必须调用同样次数的 pthread_mutex_unlock 以彻底释放这个互斥体上的锁而使其它线程可以锁定该互斥体。
>>- 当尝试第二次锁定一个纠错互斥体(error-checking mutex)的时候,GNU/Linux 会自动检测并标识对纠错互斥体上的双重锁定;这种双重锁定通常会导致死锁的出现。第二次尝试锁定互斥体时 pthread_mutex_lock 会返回错误码 EDEADLK。

>>默认情况下 GNU/Linux 系统中创建的互斥体是第一种,快速互斥体。要创建另外两种互斥体,首先应声明一个 pthread_mutexattr_t 类型的变量并且以它的地址作为参数调用pthread_mutexattr_init 函数,以对它进行初始化。然后调用 pthread_mutexattr_setkind_np函数设置互斥体的类型;该函数的第一个参数是指向互斥体属性对象的指针,第二个参数如果 是 PTHREAD_MUTEX_RECURSIVE_NP 则创建一个递归互斥体 , 或者 如果是PTHREAD_MUTEX_ERRORCHECK_NP 则创建的将是一个纠错互斥体。当 调 用pthread_mutex_init 的时候传递一个指向这个属性对象的指针以创建一个对应类型的互斥体,之后调用 pthread_mutexattr_destroy 销毁属性对象。如“np”后缀所指明的,递归和纠错两种互斥体都是 GNU/Linux 独有的,不具有可移植性(译者注:np 为 non-portable 缩写)。因此,通常不建议在程序中使用这些类型的互斥体。(当然,纠错互斥体对查找程序中的错误可能很有帮助。)

>- 非阻塞互斥体测试

>  有时候我们需要检测一个互斥体的状态却不希望被阻塞。例如,一个线程可能需要锁定一个互斥体 , 但当互斥体已经锁定的时候 , 这个线程 还 可以 处 理 其 它的 任 务 。 因 为 pthread_mutex_lock 会阻塞直到互斥体解锁为止,所以我们需要其它的一些函数来达到我们的目的。
>
>  GNU/Linux 提供了 pthread_mutex_trylock 函数作此用途。当你对一个解锁状态的互斥体调用 pthread_mutex_trylock 时,就如调用 pthread_mutex_lock 一样会锁定这个互斥体;pthread_mutex_trylock 会 返 回 0 。 而 当 互 斥 体 已 经 被 其 它 线 程 锁 定 的 时 候 ,pthread_mutex_trylock 不会阻塞。相应的,pthread_mutex_trylock 会返回错误码 EBUSY。持有锁的其它线程不会受到影响。你可以稍后再次尝试锁定这个互斥体。

>- 线程信号量

>  我们让几个线程从一个队列中取出并处理任务,每个线程函数都会尝试从队列中取得任务并当没有任务的时候结束线程函数。如果事先给队列中添加好任务,或者至少以比处理线程提取任务更快的速度向队列中添加新任务,这个模型没有问题。但如果工作线程速度太快了,任务列表会被清空而处理线程会退出,而再有新任务到达的时候就没有线程处理任务了。因此,我们更希望有这样一种机制:让工作线程阻塞以等待新的任务的到达。

>  信号量可以很方便地做到这一点。信号量是一个用于协调多个线程的计数器。如互斥体一样,GNU/Linux 保证对信号量的取值和赋值操作都是安全的,不会造成竞争状态。

>> 每个信号量都有一个非负整数作为计数。信号量支持两种基本操作:

>>- “等待”(wait)操作会将信号量的值减一。如果信号量的值已经是一,这个操作会阻塞直到(由于其它线程的一些操作)信号量的值成为正值。当信号量的值成为正值的时候,等待操作会返回,同时信号量的值减一。
>>-  “投递”(post)操作会将信号量的值加一。如果信号量之前的值为零,并且有其它线程在等待过程中阻塞,其中一个线程就会解除阻塞状态并结束等待状态(同时将信号量的值重置为 0)。

>   需要注意的是 GNU/Linux 提供了两种有少许不同的信号量实现。一种是我们这里所说的兼容 POSIX 标准的信号量实现。当处理线程之间的通信的时候可以使用这种实现。另一种实现常用于进程间通信,如果要使用信号量,应包含头文件 < semaphore.h>。

>  信号量是用sem_t类型的变量表示的。在使用一个信号量之前,你需要通过sem_init函数对它进行初始化;sem_init接受一个指向这个信号量变量的指针作为第一个参数。第二个参数应为 0 2 ,而第三个参数则指定了信号量的初始值。当你不再需要一个信号量之后,应该调用sem_destory销毁它。
>  
> 我们可以用 sem_wait 对一个信号量执行等待操作,用 sem_post 对一个信号量执行投递操作。同时 GNU/Linux 还提供了一个非阻塞版本的信号量等待函数 sem_trywait。这个函数类似 pthread_mutex_trylock——如果当时的情况应该导致阻塞,这个函数会立即返回错误代码 EAGAIN 而不是造成线程阻塞。

>  GNU/Linux 同时提供了一个用于获取信号量当前值的函数 sem_getvalue。这个函数将信号量的值保存在第二个参数(指向一个 int 类型变量的指针)所指向的变量中。不过,你不应使用从这个函数得到的值作为判断应该执行等待还是投递操作的依据。因为这样做可能导致竞争状态的出现:其它线程可能在 sem_getvalue 和随后的其它信号量函数之间开始执行并修改信号量的值。应使用属于原子操作的等待和投递代替这种做法。

>在从队列前端取走任务之前,每个线程都会等待信号量。如果信号量的值是 0,则说明任务队列为空,线程会阻塞,直到信号量的值恢复正值(表示有新任务到达)为止。

>- 条件变量

>  条件变量是 GNU/Linux 提供的第三种同步工具;利用它你可以在多线程环境下实现更复杂的条件控制。
>
>  假设你要写一个永久循环的线程,每次循环的时候执行一些任务。不过这个线程循环需要被一个标志控制:只有当标志被设置的时候才运行,标志被清除的时候线程暂停。
>
>  每次循环的时候,线程都检查这个标志是否被设置。因为有多个线程都要访问这个标志,我们使用一个互斥体保护它。这种实现虽然可能是正确的,但是效率不尽人意。当标志没有被设置的时候,线程会不断循环检测这个标志,同时会不断锁定、解锁互斥体,浪费 CPU 时间。

>  你真正需要的是这样一种方法:当标志没有设置的时候让线程进入休眠状态;而当某种特定条件出现时,标志位被设置,线程被唤醒.条件变量将允许你实现这样的目的:在一种情况下令线程继续运行,而相反情况下令线程阻塞。只要每个可能涉及到改变状态的线程正确使用条件变量,Linux 将保证当条件改变的时候由于一个条件变量的状态被阻塞的线程均能够被激活。
>
>  如同信号量,线程可以对一个条件变量执行等待操作。如果线程 A 正在等待一个条件变量,它会被阻塞直到另外一个线程,设为线程 B,向同一个条件变量发送信号以改变其状态。不同于信号量,条件变量没有计数值,也不占据内存空间;线程 A 必须在 B 发送信号之前开始等待。如果 B 在 A 执行等待操作之前发送了信号,这个信号就丢失了,同时 A 会一直阻塞直到其它线程再次发送信号到这个条件变量。

>>你可以这样使用条件变量以使前面那个例子运行得更有效率:

>>-  thread_function 中的循环检查标志。如果标志没有被设置则线程开始等待条件变量。
>>- set_thread_flag 函数在改变了标志的值之后向条件变量发送信号。这样,如果thread_function 处于等待条件变量的状态,则它会恢复运行并重新检查标志。

>> 这里有一个问题:检查状态的操作与对条件变量进行的等待或发送信号操作之间可能形成竞争状态。假设 thread_function 检查了标志,发现标志没有被设置。这时候,Linux 调度器暂停了这条线程而返回运行主线程。很偶然的,主线程正处于 set_thraed_flag 中。它设置了标志,然后向条件变量发送了信号。因为这个时候没有线程在等待这个条件变量的信号(别忘了,thread_function 在开始等待信号量上的事件之前就被暂停了执行),这个信号就此丢失了。现在,Linux 重新调度并回到原先的线程,这个线程开始等待信号并很可能会永远等待下去。

>>要解决这个问题,我们需要用一个互斥体将标志变量和条件变量绑定在一起。幸运的是,GNU/Linux 刚好提供了这个机制。每个条件变量都必须与一个互斥体共同使用,以防止这种竞争状态的发生。这种设计下,线程函数应遵循以下步骤:

>>- thread_function 中的循环首先锁定互斥体并且读取标志变量的值。
>>-  如果标志变量已经被设定,该线程将互斥体解锁然后执行工作函数.
>>- 如果标志没有被设置,该线程自动锁定互斥体并开始等待条件变量的信号.

>>这里最关键的特点就在第三条。这里,GNU/Linux 系统允许你用一个原子操作完成解除互斥体锁定和等待条件变量信号的过程而不会被其它线程在中途插入执行。这就避免了在thread_function 中检测标志和等待条件变量的过程中其它线程修改标志变量并对条件变量发送信号的可能性。

>>条件变量用 pthread_cond_t 类型表示。别忘了每个条件变量都必须与一个互斥体伴生。这里是可以用于操作条件变量的函数。

>>- 通 过 调 用 pthread_cond_init 初 始 化 一 个 条 件 变 量 。 第 一 个 参 数 是 一 个 指 向pthread_cond_t 变量的指针。第二个参数是一个指向条件变量属性对象的指针;这个参数在 GNU/Linux 系统中是被忽略的。互斥体对象必须单独被初始化。
>>- 调用 pthread_cond_signal 向一个条件变量发送信号。在该条件变量上阻塞的线程将被恢复运行。如果没有线程正在等待这个信号,则这个信号会被忽略。该函数的参数是一个指向 pthread_cond_t 类型变量的指针。相似的, pthread_cond_broadcast 函数会将所有等待该条件变量的线程解锁而不是仅仅解锁一个线程。
>>- 调用 pthred_cond_wait 会让调用线程阻塞直到条件变量收到信号。该函数的第一个参数是指向一个 pthread_cond_t 类型变量的指针,第二个参数是指向一个pthread_mutex_t 类型变量的指针。

>>当调用 pthread_cond_wait 的时候,互斥体对象必须已经被调用线程锁定。这个函数以一个原子操作解锁互斥体并锁定条件变量等待信号。当信号到达且调用线程被解锁之后,pthread_cond_wait 自动申请锁定互斥体对象。

>>当你的程序要改变你利用条件变量所维护的程序状态的时候,始终应该遵循以上这些步骤.

>>- 锁定与条件变量伴生的互斥体。
>>- 执行可能改变程序状态的指令(在我们的例子中,修改标志)。
>>- 向条件变量投递或广播信号。这取决于我们希望的行为。
>>- 将与条件变量伴生的互斥体解锁。

>   条件变量所保护的状态可以相当复杂。不过,在改变任何状态之前都应该首先锁定一个互斥体,并且在修改操作之后向条件变量发送信号。条件变量也可以用于不涉及程序状态的情况,而仅用作一种让一个线程阻塞等待其它线程唤醒的机制。信号量也可用于这个目的。

>两者之前的主要区别是,当没有线程处于阻塞状态的时候信号量会“记住”唤醒下一个被阻塞的线程,而条件变量只是简单地丢弃这个信号。另外,信号量只能发送一个唤醒信息给一个线程,而pthread_cond_broadcast 可以同时唤醒不限数量的可以被唤醒的线程。

>- 两个或多个线程的死锁

>死锁可能发生在这样一种情况:两个(或更多)线程都在阻塞等待一个只能被其它线程引发的事件。例如,当线程 A 等待线程 B 向一个条件变量发送信号而线程 B 也在等待线程 A 向一个条件变量发送信号的时候,因为两个线程都永远无法发送对方等待的信号,死锁就出现了。你应该尽力避免这种情况的发生,因为这种错误很难被察觉。

>一个可能引发死锁的常见错误是多个线程试图锁定同一组对象。假设有这样一个程序,有两个线程运行不同的线程函数却尝试锁定相同的两个互斥体。假设线程 A 先锁定互斥体 A 而后锁定互斥体 B,而线程 B 先锁定互斥体 B 而后尝试锁定互斥体 A。在一个非常不幸的情下,Linux 可能让线程 A 运行到成功锁定互斥体 A 之后,然后转而运行线程 B 直到锁定互斥体 B。接下来,两个线程都被阻塞在对方持有的互斥体上而再也无法继续运行。不仅是针对互斥体等同步对象,当针对更多种类的资源,例如文件或设备上的锁定进行同步的时候,更容易造成这种死锁问题。这种问题出现的原因是一组线程以不同的顺序锁定同一组资源。解决这个问题的方法就是确保所有线程锁定这些资源的顺序相同,这样就可以避免死锁的出现。

- GNU/Linux 线程实现

GNU/Linux 平台上的 POSIX 线程实现与其它许多类 UNIX 操作系统上的实现有所不同:在 GNU/Linux 系统中,线程就是用进程实现的。每当用 pthread_create 创建一个新线程的时候,Linux 创建一个新进程运行这个线程的代码。不过,这个进程与一般由 fork 创建的进程有所不同;具体来说,新进程与父进程共享地址空间和资源,而不是分别获得一份拷贝。“管理线程”,属于 GNU/Linux 线程内部实现细节。管理线程会在一个程序第一次调用 pthread_create 的时候自动创建。

>Shell 程序的进程控制提示

>以 [1] 开头的行是由 shell 程序输出的。当你在后台运行一个程序,shell 会分配一个任务控制代码给这个程序——在这里是 1——并打印这个程序的进程号。如果后台程序终止了,shell 会在你下次执行命令后通知你。

>- 信号处理

>  线程实际是由进程实现的。因为每个线程都是一个单独的进程,又因为信号是发送到特定进程的,究竟由哪个线程接受信号并不会成为一个问题。一般而言,从程序外发送的信号通常都是发送到程序的主线程。例如,如果一个程序通过 fork 调用产生了新进程运行一个多线程程序,父进程将得到新程序主线程所在的进程号,并通过这个进程号发送信号。当你试图向一个多线程程序发送信号的时候,通常也应该遵循这个方法。
>  
>  要注意的是 GNU/Linux 系统中 pthread 库的实现与 POSIX 线程标准的区别。在注重可移植性的程序中不要依赖程序的特定行为。在一个多线程程序中,一个线程可以给另一个特定线程发送信号。函数pthread_kill 可以做到这一点。该函数的第一个参数是线程号,第二个参数则是信号的值。

>- clone 系统调用

>  虽然同一个程序中产生的线程被实现作不同的进程,所有线程都共享虚拟内存和其它资源。而通过 fork 创建的子进程则得到所有这些的独立副本。前一种进程究竟是怎么创建的?
>Linux 的 clone 系统调用是一个更通用版本的 fork 和 pthread_create。它允许调用者指定哪些资源应在新旧进程之间共享。同时,clone 要求指定新进程运行所需的栈空间所在的内存区域。虽然我们在这里介绍了这个系统调用以满足读者的好奇心,clone 系统调用通常不应该出现在程序中。应该调用 fork 创建新进程而调用 pthread_create 创建新线程。

- 进程 Vs. 线程

>对于一些从并发处理中受益的程序而言,多进程还是多线程可能很难被抉择。这里有一些基本方针可以帮助你判断哪种模型更适合你的程序:
>
>- 一个程序的所有线程都必须运行同一个执行文件。而一个新进程则可以通过 exec函数运行一个新的执行文件。
>
>- 由于所有线程共享地址空间和资源,一个错误的线程可能影响所有其它线程。例如,通过未经初始化的指针非法访问内存可能破坏其它线程所使用的内存。而一个错误的进程则不会造成这样的破坏因为每个进程都有父进程的地址空间的完整副本。
>- 为新进程复制内存会比创建新线程存在性能方面的损失。不过,由于只有当对内存进行写入操作的时候复制操作才会发生,如果新进程只对内存执行读取操作,性能损失可能微乎其微。
>- 对于需要精细并行控制的程序,线程是更好的选择。例如,如果一个问题可以被分解为许多相对独立的子任务,用线程处理可能更好。进程适合只需要比较粗糙的并行程序。
>- 由于线程之间共享地址空间,共享数据是一件简单的任务。(不过如前所述,必须倍加小心防范竞争状态的出现。)进程之间共享属于要求使用第五章中介绍的各种IPC 机制。这虽然显得更麻烦而笨重,但同时避免了许多并行程序错误的出现。

#进程间通信

进程间通信 （Interprocss communication, IPC)是在不同进程之间传递数据的方法。例如,互联网浏览器可以向服务器发送一个请求,随后服务器会传回 HTML 信息。这样的数据传递通常是通过一种功能类似电话线路连接的套接字来完成的。另外一个例子,你可以用 ls | lpr 这个命令将一个目录下的文件名打印出来。Shell 程序会创建一个 ls 进程和一个 lpr 进程,然后用一个“管道(用 | 符号表示)”将它们连接起来。管道为这两个进程提供了一种单向通信的渠道。这个例子中,由 ls 进程向管道写入信息,而 lpr 进程则从管道读取。

>这些进程间通信机制(IPC)可以按以下标准进行区分:

>- 通信对象是否限制为相互关联的进程(即是否有共同的父进程),或者限制为共享同一个文件系统的进程,还是可以为连接到同一个网络中的不同主机上的进程。
>- 通信中的一个进程是否限制为仅能读取或者写入数据。
>- 允许参加通信的进程的总数。
>- 通信进程是否直接在通信机制(IPC)中得到同步——例如,读取数据的进程会等待直到有数据到达时开始读取。

>我们将讨论五种不同的进程间通信机制:

>- 共享内存允许两个进程通过对特定内存地址的简单读写来完成通信过程。
>- 映射内存与共享内存的作用相同,不过它需要关联到文件系统中的一个文件上。
>- 管道允许从一个进程到另一个关联进程之间的顺序数据传输。
>- FIFO 与管道相似,但是因为 FIFO 对应于文件系统中的一个文件,无关的进程也可以完成通信。
>- 套接字允许无关的进程、甚至是运行在不同主机的进程之间相互通信。

- 共享内存

共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存,就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候,其它进程都会察觉到这个更改。

>-  快速本地通信

>  因为所有进程共享同一块内存,共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快,并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。因为系统内核没有对访问共享内存进行同步,你必须提供自己的同步措施。

 >  例如,在数据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内存地址写入数据等。解决这些问题的常用方法是通过使用信号量进行同步。不过,我们的程序中只有一个进程访问了共享内存,因此在集中展示了共享内存机制的同时,我们避免了让代码被同步逻辑搞得混乱不堪。

>- 内存模型

>  要使用一块共享内存,进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后,所有进程都将脱离共享内存,并且由一个进程释放该共享内存块。

>  理解 Linux 系统内存模型可以有助于解释这个绑定的过程。在 Linux 系统中,每个进程的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址,不同的进程可以同时将同一个内存页面映射到自己的地址空间中,
从而达到共享内存的目的。

>  分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存的访问,只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建新的页面,而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块,则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面的映射关系。当对共享内存的使用结束之后,这个映射关系将被删除。当再也没有进程需要使用这个共享内存块的时候,必须有一个(且只能是一个)进程负责释放这个被共享的内存页面。

>  所有共享内存块的大小都必须是系统页面大小的整数倍。系统页面大小指的是系统中单个内存页面包含的字节数。在 Linux 系统中,内存页面大小是 4KB,不过你仍然应该通过调用 getpagesize 获取这个值。

 >- 分配

>  进程通过调用 shmget(SHared Memory GET,获取共享内存)来分配一个共享内存块。
该函数的第一个参数是一个用来标识共享内存块的键值。彼此无关的进程可以通过指定同一个键以获取对同一个共享内存块的访问。不幸的是,其它程序也可能挑选了同样的特定值作为自己分配共享内存的键值,从而产生冲突。用特殊常量 IPC_PRIVATE 作为键值可以保证系统建立一个全新的共享内存块。
该函数的第二个参数指定了所申请的内存块的大小。因为这些内存块是以页面为单位进行分配的,实际分配的内存块大小将被扩大到页面大小的整数倍。

>  第三个参数是一组标志,通过特定常量的按位或操作来 shmget。
>  >这些特定常量包括:
 >>- IPC_CREAT:这个标志表示应创建一个新的共享内存块。通过指定这个标志,我们可以创建一个具有指定键值的新共享内存块。
>>- IPC_EXCL:这个标志只能与 IPC_CREAT 同时使用。当指定这个标志的时候,就是说,如果已有一个具有这个键值的共享内存块存在, shmget 会调用失败。则这个标志将使线程获得一个“独有”的共享内存块。如果没有指定这个标志而系统中存在一个具有相通键值的共享内存块,shmget 会返回这个已经建立的共享内存块,而不是重新创建一个。
>>- 模式标志(Mode flags):这个值由 9 个位组成,分别表示属主、属组和其它用户对该内存块的访问权限。其中表示执行权限的位将被忽略。指明访问权限的一个简
单办法是利用< sys/stat.h>中指定,并且在手册页第二节stat条目中说明了的常量指定 。例如,S_IRUSR和S_IWUSR分别指定了该内存块属主的读写权限，而 S_IROTH和S_IWOTH则指定了其它用户的读写权限。
如果调用成功,shmget 将返回一个共享内存标识符。如果该共享内存块已经存在,系统会检查访问权限,同时会检查该内存块是否被标记为等待摧毁状态。

>- 绑定和脱离

>  让一个进程获取对一块共享内存的访问,这个进程必须先调用 shmat( SHared Memory Attach,绑定到共享内存)。将 shmget 返回的共享内存标识符 SHMID 传递给这个函数作为第一个参数。该函数的第二个参数是一个指针,指向你希望用于映射该共享内存块的进程内存地址;如果你指定 NULL 则 Linux 会自动选择一个合适的地址用于映射。
> 第三个参数是一个标志位,包含了以下选项:
>>- SHM_RND 表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍。如果你不指定这个标志,你将不得不在调用 shmat 的时候手工将共享内存块的大小按页面大小对齐。
>>- SHM_RDONLY 表示这个内存块将仅允许读取操作而禁止写入。
	
>  如果这个函数调用成功则会返回绑定的共享内存块对应的地址。通过 fork 函数创建的子进程同时继承这些共享内存块;如果需要,它们可以主动脱离这些共享内存块。当一个进程不再使用一个共享内存块的时候应通过调用 shmdt (SHared Memory DeTach,脱离共享内存块)函数与该共享内存块脱离。将由 shmat 函数返回的地址传递给这个函数。如果当释放这个内存块的进程是最后一个使用该内存块的进程,则这个内存块将被删除。对exit 或任何 exec 族函数的调用都会自动使进程脱离共享内存块。

>- 控制和释放共享内存块
	
>  调用 shmctl("SHared Memory ConTroL",控制共享内存)函数会返回一个共享内存块的相关信息。同时 shmctl 允许程序修改这些信息。该函数的第一个参数是一个共享内存块标识。要获取一个共享内存块的相关信息,则为该函数传递 IPC_STAT 作为第二个参数,同时传递一个指向一个 struct shmid_ds 对象的指针作为第三个参数。
要删除一个共享内存块,则应将 IPC_RMID 作为第二个参数,而将 NULLL 作为第三个参数。当最后一个绑定该共享内存块的进程与其脱离时,该共享内存块将被删除.

>  你应当在结束使用每个共享内存块的时候都使用 shmctl 进行释放,以防止超过系统所允许的共享内存块的总数限制。调用 exit 和 exec 会使进程脱离共享内存块,但不会删除这个内存块。

>- 调试

>  使用 ipcs 命令可用于查看系统中包括共享内存在内的进程间通信机制的信息。指定-m参数以获取有关共享内存的信息。如果这个共享内存块在程序结束后没有被删除而是被错误地保留下来,你可以用 ipcrm 命令删除它。ipcrm shm id

>- 优点和缺点

>  共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据,但是所有程序之间必须达成并遵守一定的协议,以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。不幸的是,Linux 无法严格保证提供对共享内存块的独占访问,甚至是在你通过使用 IPC_PRIVATE 创建新的共享内存块的时候也不能保证访问的独占性。
>  同时,多个使用共享内存块的进程之间必须协调使用同一个键值。

- 进程信号量

信号量是一个可用于同步多线程环境的计数器。Linux还提供了一个另外一个用于进程间同步的信号量实现(通常它被称为进程信号量,有时也被称为 System V 信号量)。进程信号量的分配、使用和释放方法都与共享内存块相似。尽管单个信号量足以解决大多数问题,进程信号量是按组(set)分配的。我们将展示如何利用各种 Linux 提供的各种系统调用来实现一个具有两种状态的信号量。

>- 分配和释放

>  与用于分配、释放共享内存的 shmget 和 shmctl 类似,系统调用 semget 和 semctl负责分配、释放信号量。
调用 semget 函数并传递如下参数:
一个用于标识信号量组的键值,该函数返回的是信号量组,该组中包含的信号量数量和与 shmget 所需的相同的权限位标识。该函数返回的是信号量组的标识符。你可以通过指定正确的键值来获取一个已经存在的信号量的标识符;这种情况下,传递的信号量组的容量可以为 0。

>  信号量会一直保存在系统中,甚至所有使用它们的进程都退出后也不会自动被销毁。最后一个使用信号量的进程必须明确地删除所使用的信号量组,来确保系统中不会有太多闲置的信号量组,从而导致无法创建新的信号量组。可以通过调用 semctl 来删除信号量组。
> 调用时的四个参数分别为信号量组的标识符,组中包含的信号量数量、常量 IPC_RMID 和一个 union semun 类型的任意值(被忽略)。调用进程的有效用户 id 必须与分配这个信号量的用户 id 相同(或者调用进程为 root 权限亦可)。与共享内存不同,删除一个信号量组会导致Linux 立即释放资源。

>- 初始化信号量

>  分配与初始化信号量是两个相互独立的操作。以 0 为第二参数,以 SETALL 为第三个参数调用 semctl 可以对一个信号量组进行初始化。第四个参数是一个 semun 对象,且它的 array 字段指向一个 unsigned short 数组。数组中的每个值均用于初始化该组中的一个信号量。

>- 等待和投递操作

>  每个信号量都具有一个非负的值,且信号量支持等待和投递操作。系统调用 semop 实现了这两个操作。它的第一个参数是信号量的标识符,第二个参数是一个包含 struct sembuf 类型元素的数组;这些元素指明了你希望执行的操作。第三个参数是这个数组的长度。

>>结构体 sembuf 中包含如下字段:

>>- sem_num 将要执行操作的信号量组中包含的信号量数量
>>- sem_op 是一个指定了操作类型的整数
>>- 如果 sem_op 是一个正整数,则这个值会立刻被加到信号量的值上;如果 sem_op 为负,则将从信号量值中减去它的绝对值。如果这将使信号量的值小于零,则这个操作会导致进程阻塞,直到信号量的值至少等于操作值的绝对值(由其它进程增加它的值)。
>>- 如果 sem_op 为 0,这个操作会导致进程阻塞,直到信号量的值为零才恢复。
>>- sem_flg是一个符号位。指定 IPC_NOWAIT 以防止操作阻塞;如果该操作本应阻塞,则 semop 调用会失败。如果为 sem_flg 指定 SEM_UNDO,Linux 会在进程退出的时候自动撤销该次操作。

>  指定 SEM_UNDO 标志解决当出现一个进程仍然持有信号量资源时被终止这种特殊情况时可能出现的资源泄漏问题。当一个进程被有意识或者无意识地结束的时候,信号量的值会被调整到“撤销”了所有该进程执行过的操作后的状态。例如,如果一个进程在被杀死之前减小了一个信号量的值,则该信号量的值会增长。

>- 调试信号量
命令 ipcs -s 可以显示系统中现有的信号量组的相关信息。而 ipcrm sem 命令可以从命令行删除一个信号量组。

- 映射内存

映射内存提供了一种使多个进程通过一个共享文件进行通信的机制。尽管可以将映射内存想象为一个有名字的共享内存,你始终应当记住两者之间有技术层面的区别。映射内存既可以用于进程间通信,也可以作为一种访问文件内容的简单方法。

映射内存在一个文件和一块进程地址空间之间建立了联系。Linux 将文件分割成内存分页大小的块并复制到虚拟内存中,因此进程可以在自己的地址空间中直接访问文件内容,也可以通过写入内存地址来修改文件的内容。这是一种方便的访问文件的方法。

你可以将映射内存想象成这样的操作:分配一个足够容纳整个文件内容的缓存,将全部文件内容读入缓存,并且(当缓存内容被修改过后)最后将缓存写回文件。Linux 替你完成文件读写的操作。
除了用于进程间通信,还有其它一些情况会使用映射内存。

>- 映射一个普通文件

>  要将一个普通文件映射到内存空间,应使用 mmap(映射内存,“Memory MAPped”,读作“em-map”)。函数 mmap 的第一个参数指明了你希望 Linux 将文件映射在进程地址空间中的位置;传递 NULL 指针允许 Linux 系统自动选择起始地址。
>  第二个参数是映射内存块的长度,以字节为单位。
>  第三个参数指定了对被映射内存区域的保护,由 PROT_READ、PROT_WRITE 和 PROT_EXEC 三个标志位按位与操作得到。三个值分别标识读、写和执行权限。
>  第四个参数是一个用于指明额外选项的标志值。
>  第五个参数应传递一个已经打开的、指向被映射文件的句柄。
>  最后一个参数指明了文件中被映射区域相对于文件开始位置的偏移量。通过选择适当的开始位置和偏移量,你可以选择将文件的全部内容或某个特定部分映射到内存中。

>>标志值可以由以下常量进行按位或操作进行组合得到:

>>- MAP_FIXED——如果你指定这个标志,Linux 会强制使用你提供的地址进行映射,而不只是将该地址作为一个对映射地址的参考进行选择,该地址必须按内存分页边
界对齐。
>>- MAP_PRIVATE——对映射区域内存的写操作不会直接导致对被绑定文件的修改,而是修改该进程持有的一份该文件的私有副本。其它进程不会发现这些写操作。这个模式不能与 MAP_SHARED 同时使用。
>>- MAP_SHARED——对内存的写入操作会立刻反应在被映射的文件中,而不会被系统缓冲。将映射内存作为一种 IPC 手段时应使用这个标志。这个模式不能与MAP_PRIVATE 同时使用。

>如果调用成功,mmap 会返回一个指向被映射内存区域的起点的指针。如果调用失败则返回常量 MAP_FAILED。

>当你不再使用一块映射内存的时候应调用 munmap 进行释放。将被映射内存区域的开始地址和内存块的长度作为参数调用这个函数。Linux 会在进程结束的时候自动释放进程中映射的内存区域。


>- 对文件的共享访问

>  不同进程可以将同一个文件映射到内存中,并借此进行通信。通过指定 MAP_SHARED标志,所有对映射内存的写操作都会直接作用于底层文件并且对其它进程可见。如果不指定这个标志,Linux 可能在将修改写入文件之前进行缓存。

>  除了使用 MAP_SHARED 标志,你也可以通过调用 msync 强制要求 Linux 将缓存的内容写入文件。它的前两个参数与 munmap 相同,用于指明一个映射内存块。

>>第三个参数可以接受如下标志位:

>>- MS_ASYNC——计划一次更新,但是这次更新未必在调用返回之前完成。
>>- MS_SYNC——立刻执行更新;msync 调用会导致进程阻塞直到更新完成。MS_SYNC 和 MS_ASYNC 不能同时使用。
>>- MS_INVALIDATE——其它所有进程对这个文件的映射都会失效,因此它们可以看到被修改过的值。

>与使用共享内存一样,使用文件映射内存的程序之间必须遵循一定的协议以避免竞争状态的发生。例如,可以通过一个信号量协调多个进程一块内存映射文件的并发访问。

>- 私有映射

>   在 mmap 中指定 MAP_PRIVATE 可以创建一个写时复制(copy-on-write)区域。所有对映射区域内存内容的修改都仅反映在当前程序的地址空间中;其它进程即使映射了同一个文件也不会看到这些变化。与普通情况下直接写入所有进程共享的页面中的行为不同,指定  MAP_PRIVATE 进行映射的进程只将改变写入一份私有副本中。该进程随后执行的所有读写操作都针对这个副本进行。

>- mmap 的其它用途

>  系统调用 mmap 还可以用于除进程间通信之外的其它用途。一个常见的用途就是取代 read 和 write。例如,要读取一个文件的内容,程序可以不再显式地读取文件并复制到内存中,而是将文件映射到地址空间然后通过内存读写操作来操作文件内容。对于一些程序而言这样更方便,也可能具有更高的效率。
>  
>  许多程序都使用了这样一个非常强大的高级技巧:将某种数据结构(例如各种 struct 结构体的实例)直接建立在映射内存区域中。在下次调用过程中,程序将这个文件映射回内存中,此时这些数据结构都会恢复到之前的状态。不过需要注意的是,这些数据结构中的指针都会失效,除非这些指针都指向这个内存区域内部并且这个内存区域被特意映射到与之前一次映射位置完全相同的地址。

>  另一个相当有用的技巧是将设备文件/dev/zero 映射到内存中。这个文件将自己表现为一个无限长且内容全部为 0 字节的文件。对/dev/zero 执行的写入操作将被丢弃,因此由它映射的内存区域可以用作任何用途。自定义的内存分配过程经常通过映射/dev/zero 以获取整块经过初始化的内存。

- 管道

管道是一个允许单向信息传递的通信设备。从管道“写入端”写入的数据可以从“读取端”读回。管道是一个串行设备;从管道中读取的数据总保持它们被写入时的顺序。一般来说,管道通常用于一个进程中两个线程之间的通信,或用于父子进程之间的通信。在 shell 中,| 符号用于创建一个管道。例如,下面的程序会使 shell 创建两个子进程,一个运行 ls 而一个运行 less:
% ls | less
Shell 同时还会创建一个管道,将运行 ls 的子进程的标准输出连接到运行 less 的子进程的标准输入。由 ls 输出的文件名将被按照与发送到终端时完全相同的顺序发送到 less 的标准输入。

管道的数据容量是有限的。如果写入的进程写入数据的速度比读取进程消耗数据的速度更快,且管道无法容纳更多数据的时候,写入端的进程将被阻塞,直到管道中出现更多的空间为止。换言之,管道可以自动同步两个进程。

>- 创建管道

>  要创建一个管道,请调用 pipe 命令。提供一个包含两个 int 值的数组作为参数。Pipe 命令会将读取端文件描述符保存在数组的第 0 个元素而将写入端文件描述符保存在第 1 个
元素中。

>- 父子进程之间的通信

>  通过调用 pipe 得到的文件描述符只在调用进程及子进程中有效。一个进程中的文件描述符不能传递给另一个无关进程;不过,当这个进程调用 fork 的时候,文件描述符将复制给新创建的子进程。因此,管道只能用于连接相关的进程。
注意, writer 函数中,在父进程在每次写入操作之后通过调用 fflush 刷新管道内容。否则,字符串可能不会立刻被通过管道发送出去。
	
>- 重定向标准输入、输出和错误流

>  你可能经常希望创建一个子进程,并将一个管道的一端设置为它的标准输入或输出。利用 dup2 系统调用你可以使一个文件描述符等效于另外一个。
>例如,下面的命令可以将一个进程的标准输入重定向到文件描述符 fd:   
>  dup2 (fd, STDIN_FILENO);
>符号常量 STDIN_FILENO 代表指向标准输入的文件描述符。它的值为 0。这个函数会关闭标准输入,然后将它作为 fd 的副本重新打开,从而使两个标识符可以互换使用。

>  相互等效的文件描述符之间共享文件访问位置和相同的一组文件状态标志。因此,从 fd 中读取的字符不会再次从标志输入中被读取。

>- popen 和 pclose

>  管道的一个常见用途是与一个在子进程中运行的程序发送和接受数据。而 popen 和pclose 函数简化了这个过程。它取代了对 pipe、fork、dup2、exec 和 fdopen 的一系列调用。

>  通过调用 popen 取代 pipe、fork、dup2 和 execlp 等,一个子进程被创建以执行了sort 命令,。第二个参数,”w”,指示出这个进程希望对子进程输出信息。Popen 的返回值是管道的一端;另外一端连接到了子进程的标准输入。在数据输出结束后,pclose 关闭了子进程的流,等待子进程结束,然后将子进程的返回值作为函数的返回值返回给调用进程。
>  
>   传递给 popen 的第一个参数会作为一条 shell 命令在一个运行/bin/sh 的子进程中执行。Shell 会照常搜索 PATH 环境变量以寻找应执行的程序。如果第二个参数是"r",函数会返回子进程的标准输出流以便父进程读取子进程的输出。如果第二个参数是"w",函数返回子进程的标准输入流一边父进程发送数据。如果出现错误,popen 返回空指针。

>  调用 pclose 会关闭一个由 popen 返回的流。在关闭指定的流之后,pclose 将等待子进程退出。

>-  FIFO

>  先入先出(first-in, first-out, FIFO)文件是一个在文件系统中有一个名字的管道。任何进程均可以打开或关闭 FIFO;通过 FIFO 连接的进程不需要是彼此关联的.FIFO 也被称为命名管道。

>  可以用 mkfifo 命令创建 FIFO;通过命令行参数指定 FIFO 的路径。例如,运行这个命令将在/tmp/fifo 创建一个 FIFO:     % mkfifo /tmp/fifo
        % ls -l /tmp/fifo
prw-rw-rw- 1 samuel users 0 Jan 16 14:04 /tmp/fifo
。在一个窗口ls 输出的第一个字符是 p,表示这个文件实际是一个 FIFO(命名管道)中这样从 FIFO 中读取内容:
% cat < /tmp/fifo
在第二个窗口中这样向 FIFO 中写入内容:
% cat > /tmp/fifo
然后输入几行文字。每次你按下回车后,当前一行文字都会经由 FIFO 发送到第一个窗口。通过在第二个窗口中按 Ctrl+D 关闭这个 FIFO。运行下面的命令删除这个 FIFO:         % rm /tmp/fifo

>>- 创建 FIFO

>>  通过编程方法创建一个 FIFO 需要调用 mkfifo 函数。第一个参数是要创建 FIFO 的路径,第二个参数是被创建的 FIFO 的属主、属组和其它用户权限。因为管道必然有程序读取信息、有程序写入信息,因此权限中必须包含读写两种权限。如果无法成功创建管道(如当同名文件已经存在的时 候 ) mkfifo 返 回 -1 。 当 你 调 用 mkfifo 的 时 候 需 要 包 含 < sys/types.h> 和< sys/stat.h>。

>>- 访问 FIFO

>>   访问 FIFO 与访问普通文件完全相同。要通过 FIFO 通信,必须有一个程序打开这个 FIFO 写入信息,而另一个程序打开这个 FIFO 读取信息。底层 I/O 函数(open、write、read、close 等,列举在附录 B“底层 I/O”中)或 C 库 I/O 函数(fopen、fprintf、fscanf、fclose 等)均适用于访问 FIFO。

>>  FIFO 可 以 有 多 个 读 取 进 程 和 多 个 写 入 进 程 。 来 自 每 个 写 入 进 程 的 数 据 当 到 达PIPE_BUF(Linux 系统中为 4KB)的时候会自动写入 FIFO。并发写入可能导致数据块的互相穿插。同步读取也会出现相似的问题。

>与 Windows 命名管道的区别

>Win32 操作系统的管道与Linux系统中提供的相当类似。(相关技术细节可以从Win32 库文档中获得印证。) 主要的区别在于,Win32 系统上的命名管道的功能更接近套接字。Win32 命名管道可以用于连接处于同一个网络中不同主机上的不同进程之间相互通信。Linux系统中,套接字被用于这种情况。同时,Win32 保证同一个命名管道上的多个读——写连接不出现数据交叉情况,而且管道可以用于双向交流。

>- 套接字

>  套接字是一个双向通信设备,可用于同一台主机上不同进程之间的通信,也可用于沟通位于不同主机的进程。 套接字是本章中介绍的所有进程间通信方法中唯一允许跨主机通信的方式。Internet 程序,如 Telnet、rlogin、FTP、talk 和万维网都是基于套接字的。

>  例如,你可以用一个Telnet程序从一台网页服务器获取一个万维网网页,因为它们都使用套接字作为网络通信方式 。可以通过执行telnet www.codesourcery.com 80 连接到位于www.codesourcery.com主机的网页服务器。
魔数 80 指明了连接的目标进程是运行于www.codesourcery.com的网页服务器而不是其它什么进程。成功建立连接后,试着输入 GET /。这会通过套接字发送一条消息给网页服务器,而相应的回答则是服务器将主页的 HTML代码传回然后关闭连接.
>>通常 telnet 程序用于连接到 Telnet 服务器执行远程登陆。但你也可以使用 telnet 程序连接到其它类型的服务器然后直接向它发送命令。

>- 套接字概念

>当你创建一个套接字的时候你需要指定三个参数:通信类型,命名空间和协议。通信类型决定了套接字如何对待被传输的数据,同时指定了参与传输过程的进程数量。当数据通过套接字发送的时候会被分割成段落,这些段落分别被称为一个包(packet)。
>>通信类型决定了处理这些包的方式,以及为这些包定位目标地址的方式。

>>- 连接式(Connection style)通信保证所有包都以发出时的顺序被送达。如果由于网络的关系出现包丢失或顺序错乱,接收端会自动要求发送端重新传输。
连接类型的套接字可想象成电话:发送和接收端的地址在开始时连接被建立的时候都被确定下来。
>>- 数据报式(Datagram style)的通信不确保信息被送到,也不保证送到的顺序。数据可能由于网络问题或其它情况在传输过程中丢失或重新排序。每个数据包都必须
标记它的目标地址,而且不会被保证送到。系统仅保证“尽力”做到,因此数据包可能消失,或以与发出时不同的顺序被送达。
数据报类型的通信更类似邮政信件。发送者为每个单独信息标记收信人地址。

>套接字的命名空间指明了套接字地址的书写方式。套接字地址用于标识一个套接字连接的一个端点。例如,在“本地命名空间”中的套接字地址是一个普通文件。而在“Internet 命名空间”中套接字地址由网络上的一台主机的 Internet 地址(也被称为 Internet 协议地址或 IP 地址)和端口号组成。端口号用于区分同一台主机上的不同套接字。
协议指明了数据传输的方式。常见的协议有如下几种:TCP/IP,Internet 上使用的最主要的通信议;AppleTalk 网络协议;UNIX 本地通信协议等。通信类型、命名空间和协议三者的各种组合中,只有部分是有效的。

>- 系统调用

>  套接字比之前介绍的任何一种进程间通信方法都更具弹性。这里列举了与套接字相关的系统调用:
socket——创建一个套接字
close——销毁一个套接字
connect——在两个套接字之间创建连接
bind——将一个服务器套接字绑定一个地址
listen——设置一个套接字为接受连接状态
accept——接受一个连接请求并为新建立的连接创建一个新的套接字套接字通常被表示为文件描述符。

>>- 创建和销毁套接字

>>   Socket 和 close 函数分别用于创建和销毁套接字。当你创建一个套接字的时候,需指明三种选项:命名空间,通信类型和协议。利用 PF_开头(标识协议族,protocol families)的常量指明命名空间类型。例如,PF_LOCAL 或 PF_UNIX 用于标识本地命名空间,而PF_INET 表示 Internet 命名空间。用以 SOCK_开头的常量指明通信类型。SOCK_STREAM 表示连接类型的套接字,而 SOCK_DGRAM 表示数据报类型的套接字。
>>第三个参数,协议,指明了发送和接收数据的底层机制。每个协议仅对一种命名空间和通信类型的组合有效。因为通常来说,对于某种组合都有一个最合适的协议,为这个参数指定 0 通常是最合适的选择。如果 socket 调用成功则会返回一个表示这个套接字的文件描述符。与操作普通文件描述符一样,你可以通过 read 和 write 对这个套接字进行读写。当你不再需要它的时候,应调用 close 删除这个套接字。

>>- 调用 connect

>>  要在两个套接字之间建立一个连接,客户端需指定要连接到的服务器套接字地址,然后调用 connect。客户端指的是初始化连接的进程,而服务端指的是等待连接的进程。客户端调用 connect 以在本地套接字和第二个参数指明的服务端套接字之间初始化一个连接。第三个参数是第二个参数中传递的标识地址的结构的长度,以字节计。套接字地址格式随套接字命名空间的不同而不同。

>>- 发送信息

>>  所有用于读写文件描述符的技巧均可用于读写套接字。而专门用于操作套接字的 send 函数提供了 write 之外的另一种选择,它提供了 write 所不具有的一些特殊选项;参考 send 的手册页以获取更多信息。

>- 服务器

>  服务器的生命周期可以这样描述:创建一个连接类型的套接字,绑定一个地址,调用listen 将套接字置为监听状态,调用 accept 接受连接,最后关闭套接字。数据不是直接经由服务套接字被读写的;每次当程序接受一个连接的时候,Linux 会单独创建一个套接字用于在这个连接中传输数据。
>
>  要想让客户端找到,必须用 bind 将一个地址绑定到服务端套接字。Bind 函数的第一个参数是套接字文件描述符。第二个参数是一个指针,它指向表示套接字地址的结构。它的格式取决于地址族。第三个参数是地址结构的长度,以字节计。将一个地址绑定到一个连接类型的套接字之后,必须通过调用 listen 将这个套接字标识为服务端。
> 
>  Listen 的第一个参数是套接字文件描述符。第二个参数指明最多可以有多少个套接字处于排队状态。当等待连接的套接字超过这个限度的时候,新的连接将被拒绝。它不是限制一个服务器可以接受的连接总数;它限制的是被接受之前允许尝试连接服务器的客户端总数。

>  服务端通过调用 accept 接受一个客户端连接。第一个参数是套接字文件描述符。第二个参数是一个指向套接字地址结构的指针;接受连接后,客户端地址将被写入这个指针指向的结构中。第三个参数是套接字地址结构体的长度,以字节计。服务端可以通过客户端地址确定是否希望与客户端通信。调用 accept 会创建一个用于与客户端通信的新套接字,并返回对应的文件描述符。原先的服务端套接字继续保持监听连接的状态。用 recv 函数可以从套接字中读取信息而不将这些信息从输入序列中删除。它在接受与 read 相同的一组参数的基础上增添了一个 FLAGS 参数。指定 FLAGS 为 MSG_PEEK 可以使被读取的数据仍保留在输入序列中。

>- 本地套接字

>  要通过套接字连接同一台主机上的进程,可以使用符号常量 PF_LOCAL 和 PF_UNIX 所代表的本地命名空间。它们被称为本地套接字(local sockets)或者 UNIX 域套接字 (UNIX-domain sockets)。它们的套接字地址用文件名表示,且只在建立连接的时候使用。
>
>  套接字的名字在 struct sockaddr_un 结构中指定。你必须将 sun_family 字段设置为 AF_LOCAL 以表明它使用本地命名空间。该结构中的 sun_path 字段指定了套接字使用的路径,该路径长度必须不超过 108 字节。而 struct sockaddr_un 的实际长度应由 SUN_LENG 宏计算得到。可以使用任何文件名作为套接字路径,但是进程必须对所指定的目录具有写权限,以便向目录中添加文件。

>  如果一个进程要连接到一个本地套接字,则必须具有该套接字的读权限。尽管多台主机可能共享一个文件系统,只有同一台主机上运行的程序之间可以通过本地套接字通信。本地命名空间的唯一可选协议是 0。因为它存在于文件系统中,本地套接字可以作为一个文件被列举。当结束使用的时候,调用 unlink 删除本地套接字。

>-  Internet 域套接字

>   UNIX 域套接字只能用于同主机上的两个进程之间通信。Internet 域套接字则可以用来连接网络中不同主机上的进程。

>  用于在 Internet 范围连接不同进程的套接字属于 Internet 命名空间,使用 PF_INET 表示。最常用的协议是 TCP/IP。
>传输控制协议(Transmission Control Protocol,TCP)架构于 IP 协议之上,提供了可靠的面向连接的传输。它允许主机之间建立类似电话的连接且保证数据传输的可靠性和有序性。

>  Internet 套接字的地址包含两个部分:主机和端口号。这些信息保存在 sockaddr_in 结构中。将 sin_family 字段设置为 AF_INET 以表示这是一个 Internet 命名空间地址。目标主机的 Internet 地址作为一个 32 位整数保存在 sin_addr 字段中。端口号用于区分同一台主机上的不同套接字。因为不同主机可能将多字节的值按照不同的字节序存储,应将 htons 将端口号转换为网络字节序。参看 ip 的手册页以获取更多信息。
>  
>  可以通过调用 gethostbyname 函数将一个可读的主机名——包括标准的以点分割的 IP 地址(如10.0.0.1)或DNS名(如 www.codesourcery.com)——转换为 32 位 IP 数字。这个函数返回一个指向 struct hostent 结构的指针;其中的 h_addr 字段包含了主机的 IP 数字。

>>标准端口号

>> 根据习惯,网页服务器在 80 端口监听客户端连接。多数 Internet 网络服务都被分配了标准端口号。例如,使用 SSL 的安全网页服务器的在 443 端口监听连接,而邮件服务器(利用 SMTP 协议通信)使用端口 25。

>>在 GNU/Linux 系统中,协议——服务名关系列表被保存在了/etc/services。该文件的第一栏是协议或服务名,第二栏列举了对应的端口号和连接类型:tcp 代表了面向连接的协议,而 udp 代表数据报类型的。

>> 如果你用 Internet 域套接字实现了一个自己的协议,应使用高于 1024 的端口号进行监听。

>- 套接字对

>  如前所示,pipe 函数创建了两个文件描述符,分别代表管道的两端。管道有所限制因为文件描述符只能被相关进程使用且经由管道进行的通信是单向的。而socketpair 函数为一台主机上的一对相连接的的套接字创建两个文件描述符。这对文件描述符允许相关进程之间进行双向通信。

>  它的前三个参数与 socket 系统调用相同:分别指明了域、通信类型(译者著:原文为connection style 连接类型,与前文不符,特此修改)和协议。最后一个参数是一个包含两个元素的整型数组,用于保存创建的两个套接字的文件描述符,与 pipe 的参数类似。当调用 socketpair 的时候,必须指定 PF_LOCAL 作为域。


程序18页30页44页52页53页主函数修订版60页83页89页93页95页101页和103页105页


                          笔记整理与2014.9.19