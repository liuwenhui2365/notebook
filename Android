1.当出现ViewPager不能正常显示内容时，如果基本框架都正确的时候，检查在其适配器里面是不是有isViewFromObject被重写了，只要把
它删除即可。因为继承的那个适配器类已经对那个方法处理过，所以不需要再次重写。
2.当然如果有FrameLayout的布局类没有继承FrameActivity而是继承Activity还是会出现黑屏现象。(有时候可能因为没有获取到管理
FragmentManager的对象，而直接调用导致的异常。)注意！实践发现ViewPager并不能作为顶层容器，否则会报错。最外层使用
FrameLayout来实现几大模块的切换，内部使用ViewPager实现子模块的切换，非常实用。 顶层Fragmen采用了beginTransaction的
replaceFragment的方法实现页面切换，里面嵌套的切换采用beginTransaction的add和remove的方法。
3.在Fragment中使用getSupportFragmentMangager与getChildFragmentManager的区别： The child FragmentManager is the one that 
handles Fragments contained within only the Fragment that it was added to. 
**同时注意:Fragment里面嵌套Fragment 的话：一定要用getChildFragmentManager();**
4.采用WebView里面的一个方法setWebClient()，WebViewClient中的shouldOverrideUrlLoading()方法，实现了让新打开的网页在当前的
WebView中进行显示，而不是调用Android系统自带的浏览器进行访问
5.ViewPager嵌套引起子ViewPager无法触摸问题是通过在子ViewPager的onTouchEvent中添加getParent().requestDisallowInterceptTouchEvent(true);	
getParent().requestDisallowInterceptTouchEvent(true);
禁止父控件对touch event做intercept解决的。
6.通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。
7.Fragment的beginTransaction的方法和replaceFrag的方法基本一致，使用的时候注意beginTransaction的对象调用的add或remove的方法一定是new过的
对象，不能是空对象，否则出现解析异常。
8.Android中的bundle对象用来传输数据和对象。它的用法和Intent传递数据的方式基本一致，采用键值对的方式存储。
9.Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一
定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity时，onSaveInstanceState() 会被调用。但是当用户主动去销
毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。因为在这种情况下，用户的行为决定了不需要保存Activity的状态。
通常
onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。	
10.ViewPager与ViewFlipper的区别：
A、ViewPager（android.support.v4.view.ViewPager）与ViewFlow都能够使用适配器（ViewPager--PagerAdapter；ViewFlow--BaseAdapter）进行大量
数据的
适配，并且ViewFlow也带有原点和标题的位置提示，二者比较相像；
B、ViewFlipper使用时主要在有限的少数页面切换中比较合适，并且能够自定义每一个切换动画，用于一个应用间的画面切换比较合适，类似于
ActvityGroup；
C、ViewFlow由于提供源码，所以在扩展上更强，可根据需要自行定制，比如加入循环播放等；
D、当需要再一系列不确定数据的View中滑动时，可以考虑使用ViewFlow；如果View数目确定，应该改用Fragments或者兼容库里的ViewPager。
11.在程序中使用mImageView.setImageDrawable(getResources().对ImageView设置属性的时候，
注意getDrawable(R.drawable.mlogo))设置ImageView的资源而非setBackground();
XML中，在ImageView里对android:src="@drawable/mlogo"进行设置以上属性，而不是android:background,后者不会显示效果；
12.有时候传入this作为上下文的时候回出错，可以使用getActivity（）的方法
13.Android中设置圆角的时候bottomLeftRadius是右下角，而不是左下角。在SDK版本大于14的时候已经纠正了。
14.设置点击的事件通过Id不仅可以控制控件还可以控制布局，通过布局实现点击事件只要点击布局里面
的某个控件就可以触发。
15.ProgressDialog设置为setCancelable(true)时，点击ProgressDialog以外的区域也可以让
ProgressDialog dismiss掉。但有时我们不希望是这样的效果，于是将ProgressDialog设置
setCancelable(false)，再点击ProgressDialog以外的区域就不会出现前面所说的情况了，然而这样以
来再按返回键时就不起作用了，只能等待程序执行到dissmiss处为止。
16.在Fragment中为listView适配器赋参数时可能用到布局解析器，可以直接在onCreateView()中传入，
也可以在onViewCreated()获取到Activity的对象然后获取解析器的对象。
17.如果要修改ListView的item的高度必须要设置android:minHeight="具体值"这样才行，直接设置高度无效．
18.设置隐藏参数为View.GONE.TextView和ImageView一起使用，系统会提示不建议这样做，通过修改TextView
的背景即可实现。
19.java 中的instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类
或者是它的子类的一个实例。
 用法：
result = object instanceof class
参数：
Result：布尔类型。
Object：必选项。任意对象表达式。
Class：必选项。任意已定义的对象类。
说明：如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。如果 object 不是指定类的一个实例，或者 object 是 null，则返回 false。
20.如果调用的是系统适配器没有自定义，那么布局也需要使用系统自带的才能实现数据填充，比如Spinner控件。
继承ArrayAdapter时通过getView的方法为下拉布局添加数据，注意getItem（）来获取传进了的链表数据的每一项的值，填充到每一行子控件中。
弹出来的下拉窗口，这个是复写ArrayAdapter的getDropDownView()方法来实现的，也可以通过新建一个下拉布局文件也可，该布局只能放控件不能设置布局类型，并且该布局只能是TextView，把它的ID传进去即可。
简而言之就是设置下拉布局文件的ID必须是TextView的ID。
21.如果两个控件的适配器要求一致的话，可以使用同一个适配器，然后只有new一个数据的对象即可。注意千万不能用原来的数据对象清空来实现，因为getView的方法在每次显示都会调用
那么数据就会显示的是后面添加的。
22.调用Dialog的时候会出现InvocationTargetException时，观察传进去的参数，该构造方法第一个参数为Activity的对象，不是上下文的对象。
23.如果一个接口的方法没有被执行有两种情况，没有实例化接口的对象，或者没有声明实现接口里面的方法。
24.handler的obtainMessage的使用：看源码的注释，
/**
* Returns a new {@link android.os.Message Message} from the global message pool. More efficient than
* creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).
* If you don't want that facility, just call Message.obtain() instead.
*/
这里我们的Message已经不是自己创建的了,而是从MessagePool拿的,省去了创建对象申请内存的开销。。。。。
这里大家应该都明白了。所以以后使用的时候尽量使用 Message msg = handler.obtainMessage();的形式创
建Message，不要自己New Message 至于message产生之后你使用obtainMessage 或者是 sendMessage 效率影响
并不大.同时我们也要注意以后谈论性能的时候要找准位置,譬如这里性能的问题不是在调用 obtainMessage 和 sen
dMessage 的方法上,而是调用他们之前对象的创建问题上。
25.通过Calendar的工具类获取当前时间，首先获取该类的实例，然后通过get方法把Calendar的静态变量YEAR、MONTH等传进去即可。这里注意不能直接用该类实例的静态
变量来获取，该变量的值只是键的值（一些整型数据），通过get方法来获取键对应的值。
26.onKeyDown用来表示按住手机键的时候的事件。KeyEvent.KEYCODE_BACK表示返回键的事件发生。比如APP按两次退出的事件可以由该方法来执行。
27.发送短信可以通过SmsManager类来执行，不需要进入系统短信界面，直接通过getDefault()获取该类的对象，
然后把短信内容放入到该对象的divideMessage方法里面，进行短信内容拆分，然后遍历内容列表进行发送，通过sendTextMessage（）进行发送即可，该方法的第一个参数为对方手机号码。
28.TextView通过系统自带的Html类的fromHtml方法中把网页字符串放进去，即可实现TextView显示网页。
如果要显示网页中image标签采用Html的imageGetter和TagHandler的对象来显示图片。
29.SpannableStringBuilder都可以将某段文本设置成一个Span，在Android中，Span表示一段文本的效果，例如，链接形式、图像、带背景的文本等。只是不同的是SpannableStringBuilder可以修改文本的内容。
30.subString的索引包前不包后，大部分截取函数都是如此。
31.ListView中适配器的getView方法里面尽量不要采用耗时操作，否则可能会出现卡顿的现象。
32.drawableleft/right/top/bottom只针对大部分控件，ListView也没有此属性，布局里面也没有这些属性。当该属性不生效的时候尝试放在设置背景图的前面。调用setCompoundDrawables时，
必须调用Drawable.setBounds()方法,否则图片不显示.
33.应用程序用完摄像头后，请记得调用Camera.release()释放Camera对象！如果某应用程序未能正确释放摄像头，所有后续访问摄像头的尝试（包括此应用程序自身）都将会失败，并可
能导致程序被强行关闭。
34.每次使用Camera.open()时都要检查异常。如果摄像头被占用或者不存在，未检查异常将会导致应用程序被系统强行关闭。在运行Android 2.3 (API Level 9) 以上版本的设备上，可以
用Camera.open(int)访问指定的摄像头。在拥有多于一个摄像头的设备上，以上示例代码将会访问第一个也即朝后的那个摄像头。
35.百度地图应用步骤：申请百度API对应的AK的值，把AK的值在应用配置文件中以<meta-data>里面以键值对的形式赋值，名字为com.baidu.lbsapi.API_KEY的对应值为AK的值。特别注意申请的时候
安全码为Android工程中的SHA1的值。
36.handler的sendEmptyMessage方法只发送Message对象的what的值。
37.使用canvas画布画形状时，注意坐标原点默认是从屏幕左上角。向右和向下为正。
38.AtomicBoolean 在这个Boolean值的变化的时候不允许在之间插入，保持操作的原子性方法。
39.在程序出现异常时，debug窗口无法定位时，采用logcat里面的错误级别查找具体原因，单步或跳步执行的时候定位异常时，直接在异常里面查看异常类型即可锁定原因。
40.获取系统的布局解析器context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
41.在适配器里面解析布局可以采用传参的方式，也可以通过上下文获取系统服务中的Context.LAYOUT_INFLATER_SERVICE
返回的对象即为布局解析器。适配器的notifyDataSetChanged的方法可以在自定义适配器中重写该方法，参数为适配器的数据。
42.通过输入流将图片转为drawable,采用Drawable.createFromStream(inputStream, null);
43.通过设置控件transcriptMode属性可以将Android平台的控件（支持ScrollBar）自动滑动到最底部。 
44.在String文件中标签<string-array name="">里面嵌套item标签然后通过上下文对象的getResources().getStringArray(R.array.name的值)
来获取数组里面的数据。
45.根据Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)来判断sdcard是否存在。
46.比较代码的时候注意编码格式一定要一致，否则会出现汉字编码乱码的问题。
47.在使用FragmentManager的时候要注意一定要commit，否则页面不会加进去，如果获取beginTransaction的对象的时候，提交和添加等功能必须是
同一个对象，否则页面不会显示，如果你采用getSupportFragmentManager().beginTransaction().replace(R.id.container,fragment)，必须在后面加
提交方法，不能再去采用上面的方法获取FragmentTranslation的对象，这样不是同一个对象。	
48.Eclipse中出现非正常错误，由于符号问题导致的，就要考虑括号匹配的问题。
49.当出现R文件中找不到相应的布局或控件的时候注意是不是有style文件里面有错误或者
对应的xml文件存在错误。
50.控制editText的显示与隐藏采用setTransformationMethod(HideReturnsTransformationMethod.getInstance())。
51.在eclipse的主配置文件中的Activity名字的值为包名加类名，而直接写类名是不行的，这样才能系统识别。
52.拷贝自定义控件的时候，记得要把XML文件中对应的自定义包名改过来。否则会出现调用异常。
53.拷贝过来的代码不需要的控件一定要注释完整，该控件对应的事件也要注释掉。
54.TextView显示双引号需要加转义字符\。该控件加下划线和删除线
getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG);和Paint.STROKE_TEXT_FLAG。
55.onclick事件三种方式：实现接口的方法，new接口的对象，定义接口的
对象名，并new一个对象，然后把对象名传进去。
56.配置文件里面的Activity标签有screenOrientation用来控制屏幕方向，portrait为竖屏。
57.相对布局中如果对于某个控件进行上下或左右对比时，由于该控件还没有使用，可以采用相对于@+id的方式，然后在
布局该控件的时候加上id即可。
58.由FragmentActivity跳转到Fragment获取相应的值通过Bundle的对象来获取Intent自带的值，
通过该对象的get里面的具体方法来实现。而Bundle对象是由getActivity.getIntent().getExtras()来获取。
59.网络请求拒绝的时候检查一下是否开启权限。在开启HttpURLConnection.connect()会出现IO异常，可能原因是没有
开启线程来访问获取图片。
60.Fragment之间跳转返回时，在跳转到另一个fragment之前调用mFragmentManager.beginTransaction().addToBackStack(null);
然后在目标fragment里面返回时调用mFragmentManager.popBackStack()相当于Activity中的finish（)；这里特别注意添加到返回栈和跳转到的另一个fragment一定
是同一个fragmentTransaction。
61.fragment返回时由于已经被回收所以要重新获取值，这样由后面的fragment跳转回来的就
要再次赋值，才能获取相应的值，所以从其他Fragment获取到对象时，不要对该对象做删除
里面的元素否则返回来的时候会获取不到值，只有这样才能实现从其他Fragment返回到该Fragment不发生
获取不到值的异常。
62.给ListView中的每一项放置图片时，如果没有指定那个子项对应哪个图片的话，会出现图片
位置放错的现象发生。
63.适配器里面的控件可以通过内部类的方式管理控件，在getView的方法里面判断view是否获取到，
如果没有则获取并new一个内部的设置view的tag参数为内部类，如果获取到了则直接获取tag并转为内部类。
64.一般类名和方法名包括变量名都不用加下划线，成员变量记得加m，快速修改类里面的变量的名字在Eclipse
中选中变量并重命名即可，也可以使用快捷键Alt+Shift+R即可。
65.layout_gravity表示该控件在父容器中的位置。gravity表示该控件里面内容的对齐方式。在相对布局中没有作用。
66.当一个Activity中有两个或多个Fragment要处理时，必须要生成多个事务及FragmentTransaction，
然后提交即可。
67.有时候导入的工程如果出现资源文件的错误就会无法生成R文件。特别注意判断为空的时候逻辑考虑是否加！。
68.调用一个类的静态方法该类的构造方法不会执行，同样调用Activity的静态方法里面的onCreate方法也不会
执行。
68.控件的字体颜色和背景颜色可以使用一个XML文件控制，但要注意在控件属性设置的时候不能只是背景使用该XML
字体颜色属性也使用该xml即可实现。
69.在创建Fragment时，注意在定义成员变量的时候不能通过getString的方法来获取，因为在没有调用onCreate的方法
时，没有绑定到Activity，无法执行getString的方法。
70.在跳转Activity的时候注意如果没有注册就会出现异常，但是logcat会出现提示，但如果注册后包名修改后就不会发
生参数丢失获取不到的现象发生。还有另一种方法就是通过获取该Fragment的实例对象来传递相应的参数。
提示，所以再次出现异常检查注册文件。
71.Fragment中setArgument（）方法把对象放进去之后，必须同时跳转到目标Fragment才能获取到数据。
72.从其他工程导入自定义控件的时候注意在xml文件中更改包名位置。
73.listView子布局中可以使用布局嵌套的方式，在最外层的嵌套中加Padding即可实现item之间的距离代替divider。
74.Android中遇到键盘把控件顶上去的时候在主配置文件里面添加android:windowSoftInputMode="adjustPan"即可。
75.Android中某些文本控件的ellipsize是设置文本省略号的位置。
76.调用一个类的静态方法，该类的构造方法不会执行，当执行new一个对象的时候该类的构造方法会执行，如果有
继承的父类，那么在子类构造方法调用父类的构造方法使用super即可，同理Android中也是一样在子Activity中的
onCreate方法中super即可调用父Activity的onCreate方法。
77.TextView设置删除线setPaintFlags(Paint.STRIKE_THRU_TEXT_FLAG);
78.RadioButton中padding属性是针对文字的不是整个控件的。CheckBox也一样。
79.有时候listview的item选中事件没有触发，查看是否有子控件抢占焦点，将子控件焦点给false即可。
80.软键盘的隐藏方法InputMethodManager im = (InputMethodManager)mActivity.getSystemService(Context.INPUT_METHOD_SERVICE); 
im.hideSoftInputFromWindow(mActivity.getCurrentFocus().getApplicationWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
如果没有软件盘显示则会出现获取当前焦点的时候为空指针。
81.当需要对多个控件进行判断时，默认最后返回true，然后按顺序判断各个控件是否符合条件，如果不符合就返回false。
82.fragment中调用不了runOnUIThread的方法可以通过getActivity的方法来获取调用该方法。
83.在主Activity中设置跳转Fragment的事件时，必须在该事件里面进行一次获取FragmentManager然后再调用事务，因为每个Fragment的
事务只能提交一次，必须重新开启另一个事务才可以。
84.如果要设置Fragment的按键返回事件，可以根据FragmentManager的findFragmentById或ByTag方法来获取相应的Fragment，这时需要
写一个方法用来将当前Fragment的实例对象传过来，然后获取相应的ID判断对象是否一致，然后重写按键返回事件。有时候如果继承默认的
按键返回事件就会直接退出Activity，所以有时候需要调用FragmentManager的popBackStack（）。当然还要注意设置首个Fragment的返回。
85.listView使用中会出现程序正常执行但还是崩溃的情况检查适配器的代码是否有误。
86.判断一个类的实例是否是某个类的，采用关键字instanceof比较。
87.EditText禁止用户复制粘贴只要禁用长按事件就可以实现。但是在API-11及以上的话，取消长按就不能完全有效了，最根本的是无效化
选择的操作；代码如下：editText.setCustomSelectionActionModeCallback(new ActionMode.Callback(){}）即可。
通过setSelection来设置光标的位置。
88.当出现id与控件获取的id不一致时，即根据ID找到的控件强转为不符合对应的控件时，会直接导致崩溃,还有
只要运行就会出错等非正常异常发生时，clean一下工程即可解决。
89.想把当前控件覆盖后面的控件设置后面的padding为-1.
90.自定义的listView的（item中id是从0开始，position是从1开始）itemClick事件中如果需要向另一个页面传数据则需要判断是否越界。
91.从列表获取列表的数据对象时需要判断是否为空才能获取对象的值，否则会造成空指针异常。使用equals()的时候必须确保前面的不能
为空。
92.当出现图片重复显示的情况时检查是否在布局文件和代码文件同时设置了相同的图片。
93.GridView的使用与ListView的使用方法基本相同，只是在布局文件中需要设置列数。
94.ListView的item中margin不起作用的时候可以使用padding。上下拉刷新事件没有执行相应的事件时检查是否设置上下拉刷新事件。
95.通过shape画出圆采用shape里面的属性shape设置为椭圆，然后设置子标签<size>来达到圆的效果。
96.Fragment中返回时出现没有挂到Activity可能由于线程还在继续执行，比如定时器，关闭后在执行返回即可。
97.CheckBox必须设置监听事件才能根据选中没选中进行动态判断，如果只是在初始化时判断则只执行一次。（特别要注意）有时候会发生
正在执行点击事件里面的时候跳转到checkedchangeListener事件里面了,那是因为点击事件类里面修改了控件的checked状态导致执行相应
的事件后出现该点击事件还没有执行完成就跳转到checkedchangedListener事件。
98.关于页面跳转问题，如果在一个Activity里面的Fragment跳转只要在需要清除堆里面的Fragment的时候，清除的时候采用
getBackStackEntryCount()方法获取堆里面的数量然后依次进行移除，采用popBackStack方法出堆。
99.获取当前页面的Fragment可以采用FragmentManager的对象调用findFragmentById(),然后里面传入的是xml文件中frameLayout的id即可。
100.在子线程里面如果出现Can't create handler inside thread that has not called Looper.prepare()，检查可能在子线程里面使用了
UI的动作。
101.关于设置ListView中checkbox的选中问题，在滑动ListView的时候checkbox的选中出现乱的现象，
由于在getView的方法中，在选中第一个时，滑动到另一个屏幕显示的时候出现当前页面选中，从而在
每次触发getView的时候都有相同位置的选中，所以只要设置map用来存储每个选中状态，如果需要改变只要
修改map里面的值即可，然后在显示的时候通过获取map里面对应的值确定选中与否。
102.在Fragment的replace方法中如果连续快速点击可能出现崩溃，可能由于Fragment已经添加过，点击
太快还没有进行remove，只要加判断当Fragment没有添加的时候在replace即可，这里要注意不能使用
detach来判断.
103.在开启线程访问网络时，页面返回到其他页面，当线程执行完成调用getResource或getString的方法时，
会出现当前Fragment没有attach到Activity上，这时只需要通过Activity调用getResource或getString的方法，
然后在调用之前判断Activity是否为空即可。
104.在使用Toast的时候注意Toast.makeText的方法也有可能是空指针异常。开启计时器记得在销毁View的时候
取消计时器，否则正在执行计时器事件跳转到其他页面会崩溃。
105.在Fragment中调用getString的方法前面最好通过获取当前的Activity来调用，否则有时候当前Fragment的UI
已经退出的时候线程返回的结果调用getString的方法时出现notattachActivity异常导致直接应用崩溃。
106.在ListView的刷新过程中如果对适配器里面的getView（）的View进行重用就可能造成图片错位，解决办法是
对每一个显示图片的控件添加对应的tag，然后根据tag进行定位即可实现，这里必须要注意一个问题，ListView的
高度必须是定值或者match否则还是会导致图片错位。getView()里面的position是针对ListView里面的子布局排列
顺序从0开始，ListView的setOnItemOnClick()中的position有时从0开始，如果增加了头布局，则从1开始。
107.ImageView会根据控件的大小自动将图片进行尺寸压缩，为防止图片变形，可以进行等比压缩。
108.当从一个Activity中的fragment跳转到另一个Activity的时候，返回来不再执行fragment的onCreateView等方法
而是执行onResume方法，但是从一个Activity的fragment跳转到另一个fragment的时候，返回来回执行该fragment的
onCreateView的方法。
109.xml文件中如果设置了inputType属性，editable的属性可能没有起作用，如果设置了inputType的属性又想实现不能
修改再加focusable属性即可。
110.在访问网络的时候注意返回的值的判断，最后先new一个或者增加是否为空判断，因为可能由于网络原因数据没有获取到
UI已经开始操作数据时造成空指针异常。
111.在ScrollView中添加一个android:fillViewport="true"属性就可以了。顾名思义，这个属性允许 ScrollView中的组件去充满它。
112.设置ListView的fastScrollEnable属性值为true，则在数据充满四屏的时候
右侧会出现快速导航栏。
113.根据array的xml文件中读取数组中每一个元素的id的时候，需要定义一个以
该元素为名字的一个数组，这样才能生成id。
114.getViewTreeObserver().addOnGlobalLayoutListener是在VIew画好之后才会
调用，所以在调用的方法里面进行再次画即可，实现图片等比缩放。同时获取到了控件
高度和宽度。
115.xml文件设置背景颜色切换没有作用的时候，或者只有字体颜色切换，记得要
修改选择器文件中的color属性的值调用color文件。
116.相对布局中针对某一个控件或布局进行相对定位的时候，注意只能在同一层的
时候才可以，如果在相对布局里面嵌套一个线性布局，在相对布局里面针对线性布局
里面的控件进行相对定位则会报错。
117.如果确定布局没有问题，而控件的值还是没有显示，这时就要检查代码是否修改
该控件的值,同时注意适配器里面控件是否没有找到导致空指针，在适配器里面出现空
指针时日志里面有时候找不到位置，只能调试查找。
118.TextView的drawable设置周围的图片时候无法设置图片的大小。ViewPager的高度不能
自适应否则有时候会充满全屏，导致其他控件无法显示。
119.设置背景颜色或者样式，可以通过xml文件的方式进行修改，这里需要注意如果设置
为文件的文件则要在item标签里面添加drawable属性，设置字体颜色则需要设置color属性。
120.设置HorizontalScrollView的初始滚动位置，首先要调用该控件对象的post方法，里面
new一个Runnable的方法，在里面调用smoothScrollTo或scrollTo的方法实现，里面传坐标，
表示移动的像素值，在1280*720的分辨率中1dp=2px，要获取控件的相关宽高可以在post方法里面
获取，而在onCreate中无法获取到， 因为还没有初始化完成。
去除滚动条只需要在scrollbars的属性值设置为none即可。
121.当Activity里面嵌套fragment的时候，在Activity里面触发不了在fragment里面调用的
startActivityForResult方法之后回调的onActivityResult方法，直接在fragment里面调用
onActivityResult方法即可。这里注意setResult方法在finish方法之前执行，在finish方法后
不会执行。
122.Activity里面也可以实现fragment的切换,fragmentActivity是在android3.0以前为了在里面
嵌套fragment的时候使用，android3.0以后就不需要了。
123.圆形头像自定义控件，如果图片小于控件宽度就有可能为菱形。如果xml找不到自定义的类
尝试clean工程或重启软件。
124.出现工程文件无效，检查导入工程的方式，是否从工作空间里面导入的工程，如果是则使用
另一种导入方式即可。
125.如果出现inflate某个控件的类时候发生异常，检查里面的代码是否有空指针异常发生。
126.在Activity里面可以获取到其中fragment的控件，并做相应的操作，前提是该fragment不能为空。
127.触发onTouchEvent()事件，首先要实现onTouchListener接口相应的方法，在自定义onTouchEvent
方法即可。
128.注释布局文件的时候注意关闭注释标志有时候空一行会报错，删除即可。
129.如果要去除ListView按下某个item的颜色，只要把item布局最外层颜色设置即可。
130.listView的item点击事件与item布局里面的事件冲突的时候设置item的descendantFocusability
属性即可解决冲突问题。涉及到里面控件的点击事件会影响到整个list的UI的时候需要注意，把控件
所在的view和position以参数的方式传递，在方法里面进行修改，防止UI显示混乱。
131.Eclipse出现工作空间建立失败，重启软件试试，说不定可以解决。
132.checked的属性的值系统会在你点击之后自动切换不需要考虑设置checked的属性值，如果做相反操作
或者要修改checked的状态的时候再调用那个方法。
133.遍历list的数据的时候，通过变量保存size大小和每个对象，不要每次都调用get方法和size方法影响
运行效率。通过定义view保存UI只是保存了界面，数据并没有保存，采用replace的方法再返回上一个的时候
数据会一直存在，初始化数据的时候new会把原来的数据清空重新生成一个对象。注意这个方法里面是
fragment的实例对象，直接把类放进去，会出现classcastExpection.
134.通过Bundle保存对象的时候注意要进行序列化，否则在保存的时候出现RuntimeExpection.
135.关于适配器赋值可以先生成一个适配器的对象然后通过get和set设置适配器里面的值。
136.当把一个对象赋给另一对象的时候两个对象里面的值就自动同步，除非某一个new对象，否则会一直同步。
137.string文件保存数据出现 non-positional format可能出现无法识别的符号如百分号等。或者设置formatted的属性,
还可以通过转义实现，百分号由两个转义即可。
138.在线性布局中如果要全屏显示图片就要把该控件放在整体布局上面。
139.使用ImageView显示图片，如果采用设置背景的形式显示并控制大小会出现图片变形，设置为src的属性值
就不会出现变形。
140.在通过startActivityForResult方法中调用onActivityResult方法里面接收到的结果码默认为0.
141.监听编辑框输入的内容变化，调用addTextChangeListener方法里面实现TextWatcher接口即可。
142.设置scrollView不能滚动，通过调用setOnTouchListener事件返回true即可实现不能滚动。但是里面控件的点击事件
还能触发。
143.通过setOnKeyListener事件设置物理返回键事件，必须是控件设置才能生效，有时还需要设置该控件的focusableInTouchMode
为true，才能触发返回键事件。
144.自定义控件的时候在执行onTouch事件之前会先去执行一次onDraw方法。如果更改控件里面的属性之后可以调用invalidate()进行
重画一次即可。
