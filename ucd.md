#**深入理解计算机系统**	{#welcome}

计算机系统是由硬件和软件系统组成，它们共同来运行应用程序。虽然系统的实现方式随着时间不断变化，但是系统的内在概念却没有变，理解底层计算机系统的本质和它如何影响你的应用程序。

[TOC]

----------
##**计算机系统漫游**
---------


>**程序**
是以字节的方式存储在文件中的，每个字节都有一个整数值，对应于某个字符。区分不同对象的惟一方法是我们读到对象的上下文。编译系统分为预处理阶段（ .c---.i)、编译阶段(.i---.s)、汇编阶段(.s---.o)、链接阶段(.o--可执行文件）。

>**GUN环境**
包括EMACS编辑器、GCC编辑器、GDB调试器、汇编器、链接器/、处理二进制文件的工具以及其他一些部件。贯穿整个系统的是一组电子管道，称作总线。中央处理单元（CPU）简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个被称为程序计数器（PC）的字长大小的存储设备（或寄存器），在任何一个时间点上，PC都指向主存中的某条机器语言指令（内含其地址）。系统设计者的主要目标之一是尽可能使这些拷贝操作尽可能的快。操作系统有两个基本功能：防止硬件被失控的应用程序滥用。进程是操作系统对运行程序的的一种抽象。操作系统实现这种交错执行的机制称为上下文切换。任何时刻只有一个进程在运行。
**虚拟存储器**
是一个抽象概念，它为每个进程提供两假象，好像每个进程都在独占地使用主存，每个进程看到的存储器都是一致的，称之为虚拟地址空间。内核是操作系统总是驻留在存储器的部分，操作系统内核是应用程序与硬件之间的媒介。

----------
##**优化程序性能**
---------


> **编写高效程序需要两类活动:**
> 
> - 我们必须选择一组最好的算法和数据结构.
> - 我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码.

编译技术分为“与机器有关“和”与机器无关“两类。前者指使用这些技术时可以不考虑执行代码的计算机的特性;后者指这些技术依赖于许多机器的低级细节。函数或变量多个相加的调用尽量使用与数字相乘的方式，这样可以提高代码的执行效率，优化程序性能。
对许多程序都很有用的度量标准是每元素的周期数（CPE）。处理器的活动顺序是由时钟控制的，时钟提供了某个频率的规律信号，要么兆赫兹（百万周每秒）来表示，要么用千兆赫兹表示。通过减小每元素的周期数（CPE）来优化程序性能。浮点数乘法有很高的时钟周期是由于我们基准程序数据中的异常。通过消除循环的低效率（代码移动）、减少过程调用、消除不必要的存储器引用来提高程序执行效率。
**ICU**（指令控制单元）负责从存储器中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作，而**EU**（执行单元）负责执行这些操作。**ICU**（指令高速缓存）是一个特殊的高速缓存存储器，包含最近访问的指令。最常见的控制操作数在执行单元间传送的机制称为**寄存器重命名**。
>**处理器的每个操作都是由两个周期计数值来刻画的：**
 >> - 执行时间，它指明功能单元完成操作所需要的总周期数;执行时间的范围是从基本整数操作的一个周期，到加载、存储、整数乘法和更常见的浮点操作的几个周期，到除法和其他复杂操作的许多个周期。浮点乘法器要求连续的操作之间至少有两个周期，而除法器根本没有流水线化。
 >> - 发射时间，它指明连续的、独立操作之间的周期数。

>**通常，处理器的性能受三类约束限制的:**
>> - 第一，程序中数据的相关性迫使一些操作延迟直到它们的操作数被计算出来。因为功能单元有一个或多个周期的执行时间，这就设置了一个给定的操作序列执行周期数的下界。
>> - 第二，资源约束限制了在任意给定时刻能够执行多少个操作。功能单元的有限数量就是一种资源约束，其他资源约束包括功能单元流水线化的程度，以及ICU和EU中其他资源的限制。
>> - 最后，分支预测逻辑的成功限制了处理器能够在指令流中超前工作以保持执行单元繁忙的程度。每次发生预测错误时，处理器从正确的位置重新开始都会引起很大的延迟。

通过在每次迭代中执行更多的数据操作来减少循环开销的影响使用的是**循环展开技术**，其思想是在一次迭代中访问数组元素并做乘法，这样得到的程序需要更少的迭代，从而降低了循环的开销。循环展开增加，开销会降低，而最后循环中执行的操作数会曾加，同时循环展开增加了生成目标代码的数量。

**C的一个独特的特性是能够对任意程序对象创建和引用指针。**编译器对数组代码应用非常高级的优化，而对指针代码只应用最小限度的优化，为了可读性的缘故，通常数组代码更可取一些。

>**提高并行性的方法：**
>> - 循环分割;
>> - 寄存器溢出;

>**”理论CPE“**是指当限制因素只执行时间和整数乘法器时够达到的性能。
>>基本编码原则：

>> - 消除连续的函数调用;
>> - 消除不必要的存储器引用;
>> - 低级优化：尝试各种与数组代码相对的指针形式;
>> - 通过展开循环降低循环开销;
>> - 通过诸如迭代分割之类的技术，找到使用流水线化的功能单元的方法;

>**Unix系统提供了一个剖析程序GPROF，该程序产生两种形式的信息:**
>> - 首先，它确定程序中每个函数花费了多少CPU时间;
>> - 其次，它计算每个函数被调用的次数，以调用函数来分类。
注意：该程序计时不很准确;调用信息相当可靠;默认情况下，不会显示对库函数的调用，作为替代，对库函数调用的次数体现在了调用函数的次数中。

**Gene Amdhl**（计算机领域的先驱之一）做出了一个关于提高系统一部分性能的效果的简单但是富有洞察力的观察，这个观察现在被称为Amdhl定律。主要思想是当我们加快系统一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。
主要观点：要想大幅度提高整个系统的速度，我们必须提高整个系统很大一部分的速度。

----------
##**存储器层次结构**
---------
存储器系统是一个线性的字节数组，而CPU能够在一个常数时间内访问每个存储器的位置，它实际上是一个具有不同容量、成本和访问时间的存储设备的层次结构。
具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合，具有良好局部性的程序比局部性差的程序更多地倾向于从存储器层次结构中较高层处访问数据项因此运行的更快。
>**RAS**（行访问选通脉冲）**CAS**（列访问选通脉冲）**FPM DRAM** 快页模式DRAM **EDO DRAM**扩展数据输出DRAM **SDRAM** 同步DRAM **DDR SDRAM** 双倍数据速率同步DRAM **PROM**可编程ROM **EPROM**可擦写可编程ROM **DMA

**局部性通常有两种形式：**

* 时间局部性;
* 空间局部性.

重复引用同一个变量的程序有良好的时间局部性；访问一个连续的向量的每第K个元素，就被称为步长为k的引用模式。步长为1的引用模式是程序中空间局部性常见和重要来源，**一般而言，随着步长的增加，空间局部性下降**.
对于取指令来说，循环有好的时间和空间局部性，**循环体越小，循环迭代次数越多，局部性越好。**

* 根据时间局部性，同一数据对象可能会被多次使用;
* 根据空间局部性，我们期望后面对该块中其他对象的访问能够补偿不命中的后该块的花费。

代码区别于程序数据的重要一个属性是在运行时它是不能被修改的，当程序正在执行时，CPU只从存储器中读出它的指令，CPU决不会重写或修改这些指令。 一般而言，从高层往底层走，存储设备变得更慢，更便宜和更大。
**存储器层次结构的中心思想**是：对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。数据总是以块的大小为传送单元在第k层和第k+1层之间来回拷贝。覆盖一个现存的块的过程被称为替换或驱逐这个块。被驱逐的这个块有时也被称为**牺牲块**。如果第k层的缓存是空的，那么对任何数据对象的访问都不会命中。一个空的缓存有时被称为**冷缓存**，此类不命中称为**强制性不命中或冷不命中**，该类不命中不会出现在稳定状态中，稳定状态指的就是在反复的存储器访问已经将缓存变暖之后。限制性的放置策略会引起一种不命中称为冲突不命中，这种情况下，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。
**DRAM**主存作为存储在磁盘上的数据块的缓存，是由操作系统软件和CPU上的地址翻译硬件共同管理。对于一个具有像AFS（安德鲁文件系统）这样的分布式文件系统的机器来说，本地磁盘作为缓存，它是由运行在本地机器上的AFS客户端进程管理的。在大多数的时候，缓存都是自动运行的，不需要程序采取特殊的或显式的行动。 
>高速缓存符号：组数S=2的S次方;E每个组的行数;B=2的b次方块的大小（字节）;主存物理地址位数Ｍ=以2为底Ｍ的对数；存储器地址的最大数量Ｍ=2的ｍ次方；组索引位数ｓ=以2为底Ｓ的对数；块偏移位数ｂ=以2为底Ｂ的对数；标记位数ｔ=ｍ-（ｓ+ｂ）；不包含像有效位和标记位这样开销的高速缓存大小（字节）；每组只有一行的高速缓存被称为**直接映射**高速缓存；高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程分为三步：组选择；行匹配；字抽取。

标记位和索引位连起来惟一地标识了存储器中的每个块；映射到同一个高速缓存组的块由标识位惟一地标识。组相联高速换粗放松了这条限制，所以每个组都保存有多于一个高速缓存。
一个全相联高速缓存是由一个包含所有高速缓存行的组组成的，高速缓存电路必须搜索许多匹配的标记，构造一个又大又快的相联高速缓存很困难而且昂贵，所以适合做小的高速缓存。高速缓存必须为每个高速缓存行维护一个额外的修改位，表明这个高速缓存块是否被修改过。写不命中的方法：写分配和非写分配。

高速缓存参数的性能影响：

* 不命中率；
* 命中率；
* 命中时间；
* 不命中处罚。

在直接映射高速缓存中，组和行确实是等价的，不过在相联高速缓存中，组和行不一样，组是一个或多个行的集合。确保代码高速缓存友好的方法：让最常见的情况运行得快；在每个循环内部使缓存不命中数量最小。一个程序从存储系统中读取数据是速率被称为**读吞吐率**，或者有时称为读带宽。覆盖读带宽的一个时间和空间局部性的二维函数称为存储器山。每台计算机都有惟一的存储器山，存储器山刻画了计算机的存储系统能力。当程序的时间局部性很差时，空间局部性仍然能补救。这是非常重要的。存储器山一座时间和空间局部性的山，这座山上的上升高度差别可以超过一个数量级。
使用分块来提高时间局部性，分块的思想是将一个程序中的数据结构组织称为块（应用级的数据组块）的组块，分块比非分块版本运行时间提高了一倍。
 
------------
## **系统级Ｉ／Ｏ**
------------

输入/输出（I/O)是主存和外部设备之间拷贝数据的过程。将设备优雅的映射为文件的方式，允许Unix内核引出一个简单、低级的应用接口，称为**Unix I/O**。
**进程**
是通过调用open函数来打开一个已存在的文件或创建一个新的文件。flags参数也可以是一个或更多位掩码，为写提供一些额外的指示。mode参数指定了新文件的访问权限位。

>应用程序是通过分别调用**read函数和write函数**来执行输入和输出的。通过调用lseek函数程序能够显示地修改当前文件的位置。通过调用rio_readn和rio_writen函数，应用程序可以在存储器和文件之间之接传送数据。前者只能返回一个不足值，后者决不会返回不足值。通过调用**stat和fstat函数**，检索到关于文件的信息（有时也称为文件的元数据）前者以文件名作为输入，后者以文件描述符作为输入。

普通文件包括某种文件类型的二进制或文本数据，对于内核而言，文本文件与二进制文件毫无区别。目录文件包含关于其他文件的信息。
>**套接字**是一种用来通过网络与其他进程通信的文件。Rio包通过反复执行读写操作，直到传送完所有的的请求数据，自动处理不足值。

内核用三种相关的数据结构来表示打开的文件：

* 描述符表;
* 文件表，关闭一个描述符减少相应的文件表表项中的引用计数，内核不会删除这个文件表表项，直到它的引用计数为零；
* v—node表（v-node table），同文件表一样，所以进程共享这张v-node表，每个表项包含stat结构中大多数信息，包括st_mode和st_size成员。

父子进程共享相同的打开文件表集合，因此共享相同的文件位置。在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来，其工作方式一种是使用dup2函数;
>**ANSI C**定义了一组高级输入输出函数，称为标准I/O库。该库提供了打开和关闭文件的函数**（fopen和fclose）**、读写字节的函数**（fread和fwrite）**、读和写字符串的函数**（fgets和fputs）**以及复杂的格式化I/O函数**（scanf和printf）**为程序员提供了Unix I/O的较高级别的接口。
标准I/O库将一个打开的文件模型化为一个流。一个流就是一个指向类型为FILE结构的指针。
每个ANSI C程序开始时都有三个打开的流stdin、stdout和stderr分别对应于标准输入、标准输出和标准错误。
<**注意**>在网络套接字上不要使用标准I/O函数来进行输入输出，而要使用Rio函数，如果你需要格式化输出，使用sprintf函数在存储器中格式化一个字符串，然后用rio_writen把它发送到套接口，如果你需要格式化输入，使用rio_readlineb来读一个完整的文本行，然后用scanf从文本行提取不同字段。
对于大多数应用程序而言，标准I/O更简单，是优于Unix I/O的选择。然而，因为对标准的I/O和网络文件的一些相互不兼容的限制，Unix I/O比标准I/O更适用于网络应用程序。

------------
## **网络编程**
------------
每个网络应用都是基于客户端——服务器模型的，根据这个模型，一个应用是由一个服务器进程和一个或者多个客户组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。该模型的基本操作是事务。
>一台主机可以同时运行许多不同的客户端和服务器，而且客户端和服务器的事务可以在同一台或或是不同的主机上，无论客户端和服务器是怎样映射到主机上的，客户端——服务器模型是相同的。

对静态内容的请求是通过从服务器磁盘取得文件并把它返回给客户端来服务的;对动态内容的请求是通过在服务器上一个子进程的上下文中运行一个程序并将它的输出返回给客户端来服务的。
客户端和服务器常运行在不同的主机上，并且通过计算机网络硬件和软件资源来通信。
>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是LAN（局域网），范围在一个建筑或校园内。一台主机可以发送一段位称为帧，到这个网段内其他任何主机。每个帧包括一些固定数量的头位，用来标识此帧的源和目的地址以及次帧的长度，此后紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。使用一些电缆和叫做网桥的小盒子，多个以太网段可以连接成较大的局域网，称为**桥接以太网**。该网络能够跨越整个建筑物或者校区。一些电缆连接网桥与网桥，而另外一些连接网桥和集线器。大写字母的Internet来描述一种特殊的实际应用，也就是所谓的全球IP因特网。
>>因特网的客户端和服务器混合使用套接字接口函数和Unix I/O函数来通信。套接字函数典型地是作为系统调用来实现的，这些系统会陷入内核，并调用各种内核模式的TCP/IP函数。TCP/IP实际是一个协议族，其中每一个都提供不同的功能。

UDP（不可靠数据报协议）。
>**hotnl函数**将32位整数由主机字节顺序转换为网络字节顺序，**ntohl函数**将32位整数从网络字节顺序转换为主机字节顺序，htons函数和ntohs函数为16位的整数执行相应的转换。

IP地址是以点分十进制表示法表示。在linux系统中使用HOSTNAME命令来设置你自己主机的点分十进制地址。
>因特网程序使用函数inet_aton（将一个点分十进制串（cp）转换为一个网络字节顺序的IP地址（inp））和inet_ntoa函数（将一个网络字节顺序的IP地址转换为它所对应的点分十进制串）来实现IP地址和点分十进制串之间的转换。<**注意**>对inet—aton（n表示网络a表示应用）函数的调用传递的是指向结构的指针，而inet—ntoa的调用传递的是结构本身。
因特网程序通过gethostbyname（函数返回和域名name相关的主机条目）和gethostbyaddr（函数返回和IP地址addr相关的主机条目）从DNS数据库中检索任意的主机条目。

在最简单的情况下，一个域名和一个IP地址之间是一一映射;在某些情况下，多个域名可以映射为同一个IP地址;在最通常的情况下，多个域名可以映射到多个IP地址。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的。当客户端发起一个连接请求时，客户端套接字地址中的端口通常是由内核自动分配的，称为**临时端口**。
一个连接是由它两端的套接字地址惟一确定的，这对套接字地址叫套接字对。套接字接口是一组用来结合Unix I/O函数创建网络应用的函数。
connect、bind和accept函数要求一个指向与协议相关的套接字地址结构的指针。
>客户端和服务器使用socket函数来创建一个套接字描述符。listen函数将sockfd从一个主动套接字转换为一个监听套接字，该套接字接受来自客户端的连接请求。我们创建了listenfd套接字描述符之后，我们使用setsockopt函数来配置服务器，使得它能被立即终止和重启。监听描述符是作为客户端连接请求的一个端点。
对于Web客户端和服务器而言，内容是一个MIME（多用途的国际邮件扩充协议）。
Tiny提供四种不同类型的静态内容：HTML文件、无格式文件、以及编码为GIF和JPG格式的图片。这些文件类型占据Web上提供的绝大部分静态内容。

------------
## **并发编程**
------------

>如果逻辑控制流在时间上重叠，那么它们就是并发的，这种现象称为并发性。

三种不同的构建并发程序的机制：

* 进程;
* I/O多路复用;
* 线程。

使用应用级并发的应用程序称为**并发程序**。每个逻辑控制流都是一个进程，由内核来调度和维护。
>线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。对于父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。一个线程就是运行在一个进程上下文中的一个逻辑流。

select函数处理类型为fd_set的集合，也叫做**描述符集合**。逻辑上我们将其看成一个大小为n的位掩码。该函数有两个输入：一个称为读集合的描述符集合和该读集合的元素量。
I/O多路技术可以用做并发事件驱动程序的基础，在事件驱动中，流是作为某种事件的结果前进的。自循环是同一输入和输出状态之间的转移。
>事件驱动的优点:
>>* 它比基于进程的设计给了程序员更多的对程序行为的控制;
>> - 基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中的，每个逻辑流都能访问该进程的全部地址空间，这使得在流之间共享数据变得很容易。
缺点是编码复杂。

所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。线程的上下文比进程的上下文小的多，线程的上下文比进程的上下文快的多。线程通过调用pthread_creat函数来创建其他线程。当顶层的线程例程返回时，线程会隐形的终止，通过调用pthread_exit函数线程会显式的终止，该函数会返回一个指向返回值thread_return的指针，如果主函数调用pthread_exit函数，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为thread_return。另一个对等线程通过带调用当前线程ID来的pthread_cancle函数来终止当前线程。通过调用pthread_join函数等待其他线程终止。
一个可结合的线程能够被其他线程收回资源和杀死，在被其他线程回收之前，它的存储器资源是不释放的;而一个分离（pthread_detach函数）的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。函数pthread_once允许你出适合初始化与线程例程相关的状态。
>一个进度图将n个并发线程的执行模型化为一条n维笛卡尔积空间中的轨线，每条轴k对应于线程k的进度，每个点代表线程k已经完成了指令这一状态。图中原点代表对应于没有任何线程完成一条指令的初始状态。一个进度图将指令执行模型转化为一个从一种状态到另一个状态的转换。

环绕不安全区的轨线叫做**安全轨线**，接触任何不安全区的轨线就叫做**不安全轨线**。
>信号量不变性为控制并发程序的轨线而避免不安全区提供来强有力的工具，基本思想是将每个共享变量（或者相关共享变量集合）与一个信号量s（初始为1）联系起来，然后用P（s）和V（s）操作将相应的临界区包围起来，以这种保护共享变量的信号量叫做二进制信号量，因为它的值总是1或0.信号量操作确保了对临界区的互斥访问，一般现象称为互斥。一个已经对一个互斥锁加锁但还没有解锁的线程被称为占用互斥锁。程序通过调用sem_init来初始化一个信号量。 

四类线程不安全函数：

* 不保护共享变量的函数;
* 保持跨越多个调用的状态的函数;
* 返回指向静态变量的指针的函数（处理方法：重写函数;加锁拷贝技术）；
* 调用线程不安全函数的函数。

当被多个线程调用时不会引用任何共享数据的函数称为可重入函数，该函数是线程安全函数的一个真子集。如果所有的函数参数都是传值传递的（也就是没有指针），并且所有的数据引用都是本地的自动栈变量（也就是没有引用静态或全局变量），那么这个函数是**显式可重入**的，也就是无论它是被如何调用的，我们都确定它是可重入的;如果允许显式可重入函数是引用传递的（也就是允许它们传递指针），那么就称为是**隐式可重入的函数**，也就是调用线程小心地传递指向非共享数据的指针时，它才是可重入的。一组线程被阻塞来，等待一个永远也不为真的条件。

[TOC]

