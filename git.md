# git总结    {#welcome}

=====================

Git分为Gi**本地版本控制、集中化版本控制系统（CVCS ）、分布式版本控制系统（DVCS）**。git和其他版本的控制系统主要差别在于git只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。git更像是把变化的文件作快照后，记录在一个微型的文件系统，每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一次快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，git不会再次保存，而只对上次快照作一连接。

----------
##git基础/分支
---------

 常用的git操作大多是把数据添加到数据库。对于任何一个文件，在git内都只有三种状态：**已提交（committed），已修改（modified）和已暂存（staged）。git管理项目时，文件流转的三个工作区域：git的本地数据目录，工作目录以及暂存区域。**每个项目都有一个git目录，它是git用来保存元数据和对象数据库的地方，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据;从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录;所谓的暂存区域只不过是个简单的文件，一般都放在git目录中，有时候人们吧这个文件叫做索引文件，不过标准说法还是叫暂存区域。

**git工作流程**：在工作目录中修改某些文件;对这些修改了的文件作快照，并保存到暂存区域;提交更新，将保存在暂存区域的文件快照转储到git目录中。/etc/gitconfig文件系统中对所有用户普遍适用的配置—system选项;～/。git config文件用户目录下的配置文件只适用于该用户—global选项;命令git config –global user.Name   “ＹＯＵＲ　ＮＡＭＥ”   电子邮件将name改为email 引号去掉即可。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉—global选项重新配置即可，新的设定保存在当前项目的。git/config文件里。
设置文本编辑器的命令：git config –global core.Editor 编辑器名字;git config –global merge.tool vimdiff设置差异分析工具。

**两种获得git仓库的方法**：第一种是在现存的目录下,通过导入所有文件来创建 新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。工作目录下面的所有文件都不外乎这两种状态:已跟踪或未跟踪。**已跟踪的文件** 是指本来就被纳入版本控制管理的文件,在上次快照中有它们的记录,工作一段时间后,它 们的状态可能是未更新,已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它 们既没有上次更新时的快照,也不在当前的暂存区域。初次克隆某个仓库时,工作目录中的 所有文件都属于已跟踪文件,且状态为未修改。**特别注意**：运行了 git add 之后又作了 修订的文件,需要重新运行 git add 把最新版本重新暂存起来。 文件 .gitignore 的格式规范如下: 所有空行或者以注释符号 # 开头的行都会被 Git 忽略; 可以使用标准的 glob 模式匹配;匹配模式最后跟反斜杠(/)说明要忽略的是目录; 要忽略指定模式以外的文件或目录,可以在模式前加上惊叹号(!)取反。**所谓的 glob 模式**是指 shell 所使用的简化了的正则表达式。星号(*)匹配零个或多个任 意字符;[abc] 匹配任何一个列在方括号中的字符(这个例子要么匹配一个 a,要么匹配一 个b,要么匹配一个 c);问号(?)只匹配一个任意字符;如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配(比如 [0-9] 表示匹配所有 0 到 9 的数字)。**git diff** 会使用文件补丁的格式显示具体添加和删除的行。 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用 git diff --cached 命令。**注意**：git diff 不过是显示还没有暂存起来的改动。给 git commit 加上 -a 选项,Git 就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过 git add 步骤 。**改文件名字命令**：git mv 原文件名 新文件名；不过有时候用其他工具批处理改名的话,要记得在提交前删除老的文件 名,再添加新的文件名。在提交了若干更新之后,又或者克隆了某个项目,想回顾下提交历史,可以使用 git log 命令，我们常用 -p 选项展开显示每次提交的内容差异,用 -2 则仅显示最近的两次更新.想要撤消刚才的提交操作,可以使用 --amend 选项重新提交 ：git commit –amend;git reset HEAD <file>... 的方式取消暂存。

**远程仓库**是指托管在网络上的项目仓库,可能会有好多个,其中有些你只能读,另外有些可以写。同他人协作 开发某个项目时,需要管理这些远程仓库,以便推送或拉取数据,分享各自的工作进展。管理远程仓库的工作,包括添加远程库,移除废弃的远程库,管理各式远程库分支,定义是否 跟踪这些分支,等等。**要查看当前配置有哪些远程仓库,可以用 git remote 命令**,它会列出每个远程库的简短字。在克隆完某个项目后,至少可以看到一个名为origin 的远程库,Git 默认使用这个 名字来标识你所克隆的原始仓库.可以加上 -v 选项(译注:此为 —verbose 的简写,取首字母),显示对应的克隆地 址.要添加一个新的远程仓库,可以指定一个简单的名字,以便将来引用,运行 git remote add [shortname] [url] ;从远程仓库抓取数据到本地 的命令：**git fetch** [remote-name] 此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。 fetch 命令只是将远端的数据拉到本地仓库,并不自动合并到当前工作分支,只有当你确实准备好了,才能手工合并。 将本地仓库中的数据推送到远程 仓库 命令：**git push** [remote-name] [branch-name]。 通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息。注意,对远程仓库的重命名,也会使对应的分支名称发生变化,原来的 pb/master 分支 现在成了 paul/master。 碰到远端仓库服务器迁移,或者原来的克隆镜像不再使用,又或者某个参与者不再贡献代 码,那么需要移除对应的远端仓库,可以运行 git remote rm 命令。列出现有标签的命令非常简单,直接运行 **git tag** ；

Git 使用的标签有两种类型:**轻量级的(lightweight)和含附注的(annotated)**。轻量级标签就像是个不会变化的分支,实际上它就是个指向特定提交对象的引用。而含附注标签（用-a (译注:取 annotated 的首字母)指定标签名字）,实际上是存储在仓库中的一个独立对象,它有自身的校验和信息,包含着标签的名字, 电子邮件地址和日期,以及标签说明,标签本身也允许使用 GNU Privacy Guard (GPG) 来 签署或验证。一般我们都建议使用含附注型的标签,以便保留相关信息; 可以使用 **git show** 命令查看相应标签的版本信息,并连同显示打标签时的提交对象。 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标 签,一个 -a,-s 或 -m 选项都不用,直接给出标签名字即可。可以使用 **git tag -v [tag-name]** (译注:取 verify 的首字母)的方式验证已经签署的 标签。运行 **git push origin [tagname]** 即可分享标签。如果要一次推送所有(本地新增的)标签上去,可以使用 --tags 选项:。

>初始化后,在当前目录下会出现一个名为 .git 的目录,所有 Git 需要的数据和资源都 存放在这个目录中.**克隆仓库**的命令格式为 git clone [url]。在Git中提交时,会保存一个提交(commit)对象,它包含一个指向暂存内容快照的指针,作者和相关附属信息,以及一定数量(也可能没有)指向该提交对象直接祖先的指针:第一次提交是没有直接祖先的,普通提交有一个祖先,由两个或多个分支合并产生的提交则 有多个祖先。
>当使用 git commit新建一个提交对象前,Git会先计算每一个子目录(本例中就是项目根目录)的校验和,然后在 Git 仓库中将这些目录保存为树(tree)对象。之后Git创建的提交对象,除了包含相关提交信息以外,还包含着指向这个树对象(项目根目录)的指针,如此它就可以在将来需要的时候,重现此次快照的内容了。Git 中的分支,其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用master作为分支的默认名字。在若干次提交后,你其实已经有了一个指向最后一次提交对象的master分支,它在每次提交的时候都会自动向前移动。新建一个 testing 分支,可以使用 git branch 命令: git branch testing;**要切换到其他分支,可以执行 git checkout 命令。** 用 git merge 命令来进行**合并**。合并回 master 分支,实际操作同前面合并 hotfix 分支差不多,只需检出想要更新的分支(master),并运行 git merge 命令指定来 源: 如果你想用一个有图形界面的工 具来解决这些问题,不妨运行 git mergetool,它会调用一个可视化的合并工具并引导你解 决所有冲突。若要查看各个分支最后一次 commit 信息,运行 git branch -v 。
> 一个特性分支是指一个短期的,用来实现单一特性或与其相关工作的分支。注意：当你在使用分支及合并的时候, 一切都是在你自己的 Git 仓库中进行的 —— 完全不涉及与服务器的交互。

**远程分支**(remote branch)是对远程仓库状态的索引。它们是一些无法移动的本地分 支;只有在进行 Git 的网络活动时才会更新。远程分支就像是书签,提醒着你上次连接远 程仓库时上面各分支的位置。可以运行 git fetch origin 来进行同步。 在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。如果要把该内容合并到当前分支,可以运行 git merge origin/serverfix。 从远程分支检出的本地分支,称为跟踪分支(tracking branch)。跟踪分支是一种和远程 分支有直接联系的本地分支。在跟踪分支里输入 git push,Git 会自行推断应该向哪个服 务器的哪个分支推送数据。反过来,在这些分支里运行 git pull 会获取所有远程索引,并 git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支,运行下面的命令: 把它们的数据都合并到本地分支中来。git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支,运行下面的命令: 	
把一个分支整合到另一个分支的办法有两种:**merge(合并) 和 rebase(衍合)**。 rebase 命令,就可以把在一个分支 里提交的改变在另一个分支里重放一遍,该操作叫衍合git rebase [主分支] [特性分支] 命令会先检出特性分支 server,然后在主分支 master 上重演 。记住：永远不要衍合那些已经推送到公共仓库的更新。
>架设一个 Git 服务器不难。第一步是选择与服务器通讯的协议。 远程仓库通常只是一个 纯仓库(bare repository) ——一个没有当前工作目录的仓库。 纯仓库是你项目里 .git 目录的内容,别无他物。 Git 可以使用四种主要的协议来传输数据:本地传输,SSH 协议,Git 协议和 HTTP 协 议。要添加一个本地仓库到现有 Git 工程,运行如下命令: git remote add local_proj /opt/git/project.git 。把一个仓库克隆为纯仓库,可以使用 clone 命令的 --bare 选项。纯仓库的目录名以 .git 结尾, 

**本地仓库** 运行类似 git pull /home/john/project通常会比他们推送到服务器,而你又从服务器获取简单得多。在同一个服务器上,如果二者同时允许 Git访问本地硬盘,通过 NFS 访问仓库通常会比 SSH 慢。**SSH**也是唯一一个同时便于读和写操作的网络协议。另外两个网络协议(HTTP 和 Git)通常都是只读的，SSH 公钥默认储存在账户的 ~/.ssh 目录。
使用命令： git clone ssh://user@server:project.git  **Git协议**这是一个包含在Git软件包中的特殊守护进程;它会监听一个提供类似于 SSH 服务的特定端口(9418),而无需任何授权。用 Git 协议运营仓库,你需要
创建 git-export-daemon-ok文件——它是协议进程提供仓库服务的必要条件——但除此之外该服务没有什么安全措施。Git协议的设定都相对简单。基本上,只要以长期守护进程的形式运行该命令:git daemon --reuseaddr --base-path=/opt/git/ /opt/git/ ；--reuseaddr 使得服务无须等到旧的连接尝试过期以后，--base-path 选项使得隆项目的时候不用给出完整的路径,而最后面的路径告诉Git进程导出仓库的位置。

**HTTP或HTTPS协议**的优美之处在于架设的简便性。基本上, 只需要把 Git 的纯仓库文件放在 HTTP的文件根目录下,配置一个特定的 post-update 挂钩(hook),就搞定了。Git附带的post-update挂钩会默认运行合适的命令(git update-server-info)来确保通过HTTP的获取和克隆正常工作。注意的是,每次添加一个新项目都需要通过shell登入主机并创建一个纯仓库。如果你一不小心搞错了配置,失去了推送权限,可以手动修改服务器上的 /home/git/.gitosis 文件—— Gitosis 从该文件读取信息。一次推送会把 gitosis.conf 保存在服务器上。如果你手动编辑该文件,它将在你下次向 gitosis-admin 推送之前它将保持原样。
假如不想使用 Gitosis,而又想架设一个 Git 协议进程,则必须为每一个想使用 Git 进
程的项目运行如下命令:$ cd /path/to/project.git $ touch git-daemon-export-ok

-----------
##**GitHub**
-----------
    
    GitHub 是到目前为止最大的开源Git托管服务,并且是少数同时提供公共托管和私人托管服务的站点之一,所以你可以在一个站点同时保存
开源和商业代码。
    第一个必要必要步骤是注册一个免费的账户。访问 Pricing and Signup (价格与注册)页面 http://github.com/plans 并点击 Free 
acount (免费账户)的 “Sign Up(注册)”按钮,进入注册页面。这里要求选择一个系统中尚未存在的用户名,提供一个与之相连的电邮地址,以及
一个密码。
    第二步创建新仓库，点击用户面板上仓库旁边的 “create a new one(新建)” 连接。进入 Create a NewRepository(新建仓库)表格，唯一必做的仅仅是提供一个项目名称,当然也可以添加一点描述。搞定这些以后,点“Create Repository(建立仓库)” 按钮。这样新仓库就建立起来了。要把一个非 Git 项目变成 Git 项目,运行*`

strong text
-----------

`*git init , git add . git commit -m 'initial commit'一旦拥有一个本地 Git 仓库,把 GitHub 添加为远程仓库并推送 master 分支:$ git remote add origin git@github.com:testinguser/iphone_project.git
$ git push origin master这时该项目就托管在 GitHub 上了。你可以把它的 URL 发给每个希望分享该工程的人。本例的URL是http://github.com/testinguser/iphone_project。
    如果想把某个公共Subversion项目导入Git,GitHub可以帮忙。在指南的最后有一个指向导入 Subversion 页面的链接。点击它,可以得到一个表格,它包含着有关导入流程的信息以及一个用来粘贴公共 Subversion 项目连接的文本框。
    它包含了该项目不同方面的标签。Commit标签将按时间展示逆序的 commit 列表,与 git log 命令的输出类似。Network标签展示所有fork了该项目并做出贡献的用户的关系图。Downloads 标签允许你上传项目的二进制文件,并提供了指向该项目所有标记过的位置的 tar/zip 打包下载连接。Wiki标签提供了一个用来撰写文档或其他项目相关信息的 wiki。Graphs 标签包含了一些可视化的项目信息与数据。刚开始进入的 Source 标签页面列出了项目的主目录;并且在下方自动展示README文件的内容(如果该文件存在的话)。该标签还包含了最近一次提交的相关信息。
    如果想向一个自己没有推送权限的项目贡献代码,GitHub提倡使用派生(forking)。在你发现一个感兴趣的项目,打算在上面Hack一把的时候,可以点击页面上方的“fork(派生)” 按钮,GitHub会为你的用户复制一份该项目,这样你就可以向它推送内容了。

-----------
##*分布式git*
-----------
    
    在集中式系统上,每个开发者就像是连接在集线器上的节点,彼此的工作方式大体相像。而在 Git 网络中,每个开发者同时扮演着节点和集线器的角色,这就是说,每一个开发者都可以将自己的代码贡献到另外一个开发者的仓库中,或者建立自己的公共仓库,让其他开发者基于自己的工作开始,为自己的仓库贡献代码。
> **分布式工作流程:**

> - 集中式工作流程使用的都是单点协作模型。一个存放代码仓库的中心服务器,可以
接受所有开发者提交的代码。所有的开发者都是普通的节点,作为中心集线器的消费者,平时的工作就是和中心仓库同步数据.注意：你必须先拉取最新数据下来,手工解决冲突合并后,才能继续推送新的提交。

> - 集成管理员工作流：
   1. 项目维护者可以推送数据到公共仓库 blessed repository。
   2. 贡献者克隆此仓库,修订或编写新代码。
   3. 贡献者推送数据到自己的公共仓库 developer public。
   4. 贡献者给维护者发送邮件,请求拉取自己的最新修订。
   5. 维护者在自己本地的 integration manger仓库中,将贡献者的仓库加为远程仓库,
      合并更新并做测试。
   6. 维护者将合并后的更新推送到主仓库 blessed repository。
人们可以复制(fork 亦即克隆)某个项目到自己的列表中,成为自己的公共仓库。随后将自己的更新提交到这个仓库,所有人都可以看到你的每次更新。这么做最主要的优点在于,你可以按照自己的节奏继续工作,而不必等待维护者处理你提交的更新;而维护者也可以按照自己的节奏,任何时候都可以过来处理接纳你的贡献。
> - 司令官与副官工作流，各个集成管理员分别负责集成项目中的特定部分,所以称为副官(lieutenant)。而所有这些集成管理员头上还有一位负责统筹的总集成管理员,称为司令官(dictator)。司令官维护的仓库用于提供所有协作者拉取最新集成的项目代码。
   1. 一般的开发者在自己的特性分支上工作,并不定期地根据主干分支(dectator 上的
      master)衍合。
   2. 副官(lieutenant)将普通开发者的特性分支合并到自己的 master 分支中。
   3. 司令官(dictator)将所有副官的 master 分支并入自己的 master 分支。
   4. 司令官(dictator)将集成后的 master 分支推送到共享仓库 blessed repository
      中,以便所有其他开发者以此为基础进行衍合。
这种工作流程并不常用,只有当项目极为庞杂,或者需要多级别管理时,才会体现出优势。用这种方式,项目总负责人(即司令官)可以把大量分散的集成工作委托给不同的小组负责人分别处理,最后再统筹起来,如此各人的职责清晰明确,也不易出错.

-----------
##*提交指南*
-----------
   
   首先,请不要在更新中提交多余的白字符(whitespace)。Git有种检查此类问题的方法,在提交之前,先运行gitdiff--check,会把可能的多余白字符修正列出来。接下来,请将每次提交限定于完成一次逻辑功能。并且可能的话,适当地分解为多次小更新,以便每次小型提交都更易于理解。最后需要谨记的是提交说明的撰写。写得好可以让大家协作起来更轻松。一般来说,提交说明最好限制在一行以内,50个字符以下,简明扼要地描述更新内容,空开一行后,再展开详细注解，运行gitlog--no-merges看看,所有提交历史的说明是怎样撰写的。先在自己的特性分支中工作一段时间,完成后合并到自己的master分支;然后下载合并 origin/master上的更新(如果有的话),再推回远程服务器。request-pull命令接受两个参数,第一个是本地特性分支开始前的原始分支,第二个是请求对方来抓取的 Git 仓库 URL。--squash 选项将目标分支上的所有更改全拿来应用到当前分支上,而 --no-
commit 选项告诉 Git 此时无需自动生成和记录(合并)提交。 git format-patch 命令来生成 mbox 格式的文件然后作为附件发送。每个提交都会封装为一个 .patch 后缀的 mbox 文件,但其中只包含一封邮件,邮件标题就是提交消息(译注:额外有前缀,看例子),邮件内容包含补丁正文和 Git 版本号。
    新建临时分支: gitbranchsc/ruby_clientmaster如果你希望立即转到分支上去工作,可以用 checkout -b:如果收到的补丁文件是用 git diff 或由其它 Unix 的 diff 命令生成,就该用 git apply 文件地址 命令来应用补丁。it apply是一个事务性操作的命令,也就是说,要么所有补丁都打上去,要么全部放弃。在实际打补丁之前,可以先用 git apply --check 查看补丁是否能够干净顺利地应用到当前分支中;对于 format-patch 制作的新式补丁,应当使用 git am 命令。从技术上来说,git am 能够读取 mbox 格式的文件。如果你的邮件客户端能将多封电邮导出为 mbox 格式的文件,就可以用git am 一次性应用所有导出的补丁。如果贡献者有自己的 Git 仓库,并将修改推送到此仓库中,那么当你拿到仓库的访问地址和对应分支的名称后,就可以加为远程分支,然后在本地进行合并。
**大项目合并流程**将贡献者的代码引入为不同的特性分支然后测试评估,看哪些特性能稳定工作,哪些还需改进。稳定的特性可以并入 next 分支,然后再推送到公共仓库,以供其他人试用。
    如果在一个刚刚打完标签的提交上运行describe命令,只会得到这次标定的版本号,而没有后面两项信息。
    
----------
##*git工具/自定义git*
----------
想要看类似于 git log 输出格式的引用日志信息,你可以运行 git log -g:你可以在命令行下通过git add -p或者git add --patch来启动同样的脚本。‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中,随时可以重新应用。为了往堆栈推送一个新的储藏,只要运行 git stash:要查看现有的储藏,你可以使用 git stash list。apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它,你可以运行git stash drop,加上你希望移除的储藏的名字,可以运行 git stash pop 来重新应用储藏,同时立刻将其从堆栈中移走。如果你想用更方便的方法来重新检验你储藏的变更,你可以运行 git stash branch,这会创建一个新的分支,检出你储藏工作时的所处的提交,重新应用你的工作,如果成功,将会丢弃储藏。如果你只想修改最近一次提交说明,命令: git commit --amend拆分提交就是撤销一次提交,然后多次部分地暂存或提交直到结束。可以用filter-branch来更换多次提交里的电子邮件地址。你必须小心一些,只改变属于你的电子邮件地址,所以你使用--commit-filter。如果你在追踪代码中的缺陷想知道这是什么时候为什么被引进来的,文件标注会是你的最佳工具。它会显示文件中对每一行进行修改的最近一次提交，用git blame来标注文件，如果你在gitblame后加上-C,Git会分析你在标注的文件然后尝试找出其中代码片段的原始出处,如果它是从其他地方拷贝过来的话。bisect会在你的提交历史中进行二分查找来尽快地确定哪一次提交引入了错误。首先你运行git bisect start启动,然后你用git bisect bad来告诉系统当前的提交已经有问题了。然后你必须告诉bisect已知的最后一次正常状态是哪次提交,使用git bisect good [good_commit]:首先你需要提供已知的错误和正确提交来告诉它二分查找的范围。你可以通过bisect start命令来列出它们,先列出已知的错误提交再列出已知的正确提交。首先你要把外部的仓库克隆到你的子目录中，通过git submodule add将外部项目加为子模块，git submodule init来初始化你的本地配置文件,git submodule update来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交。子树归并的思想是你拥有两个工程,其中一个项目映射到另外一个项目的子目录中,反过来也一样。当你指定一个子树归并,Git可以聪明地探知其中一个是另外一个的子树从而实现正确的归并——这相当神奇。
       用git config配置 Git,要做的第一件事就是设置名字和邮箱地址: git config --global user.name "xxx"； git config --global user.email xxx。core.pager指定 Git 运行诸如log、diff等所使用的分页器。设置密钥ID如下: git config --global user.signingkey <gpg-key-id>。现在你能够签署标签,从而不必每次运行git tag命令时定义密钥:git tag -s <tag-name>。设置color.ui为true来打开所有的默认终端着色。其 他 的 参 数 还 有 false 和 always,false意味着不为输出着色,而always则表明在任何情况下都要着色,即使 Git命令被重定向到文件或管道。在大多数情况下,如果你想在被重定向的输出中插入颜色码,你能传递--color标志给 Git 命令来迫使它这么做,color.ui = true应该是你的首选。一些设置项也能被运用于特定的路径中,这样,Git 以对一个特定的子目录或子文件集运用那些设置项。这些设置项被称为 Git 属性,可以在你目录中的.gitattributes文件内进行设置(通常是你项目的根目录),也可以当你不想让这些属性文件和项目文件一同提交时,在.git/info/attributes进行设置。你能写自己的过滤器,在提交文件到暂存区或签出文件时替换关键字。有2种过滤器,“clean”和“smudge”。在 .gitattributes文件中,你能对特定的路径设置一个过滤器,然后设置处理文件的脚本,这些脚本会在文件签出前和提交到暂存区前(“clean”)被调用。文件会随着项目一起提交,而过滤器(例如:dater)不会,所以,过滤器不会在所有地方都生效。当你在设计这些过滤器时要注意,即使它们无法正常工作,也要让整个项目运作下去。当产生一个归档时,可以设置 Git 不导出某些文件和目录。如果你不想在归档中包含一个子目录或文件,但想他们纳入项目的版本管理中,你能对应地设置export-ignore属性。现在,当运行git archive来创建项目的压缩包时,那个目录不会在归档中出现。
       
    git挂钩有两组挂钩:客户端和服务器端。客户端挂钩用于客户端的操作,如提交和合并。服务器端挂钩用于Git服务器端的操作,如接收被推送的提交。挂钩都被存储在 Git 目录下的hooks子目录中,即大部分项目中的.git/hooks。prepare-commit-msg挂钩在提交信息编辑器显示之前,默认信息被创建之后运行。commit-msg挂钩接收一个参数,此参数是包含最近提交信息的临时文件的路径。post-commit挂钩在整个提交过程完成后运行,他不会接收任何参数,但可以运行git log-1 HEAD来获得最后的提交信息。总之,该挂钩是作为通知之类使用的。推送到服务器前调用的挂钩可以在任何时候以非零退出,拒绝推送,返回错误消息给客户端,还可以如你所愿设置足够复杂的推送策略。post-commit挂钩在整个提交过程完成后运行,他不会接收任何参数,但可以运行git log-1 HEAD来获得最后的提交信息。总之,该挂钩是作为通知之类使用的。处理来自客户端的推送(push)操作时最先执行的脚本就是 pre-receive 。它从标准输入(stdin)获取被推送引用的列表;如果它退出时的返回值不是0,所有推送内容都不会被接受。利用此挂钩脚本可以实现类似保证最新的索引中不包含非fast-forward类型的这类效果;抑或检查执行推送操作的用户拥有创建,删除或者推送的权限或者他是否对将要修改的每一个文件都有访问权限。只要 update 脚本存在并且可执行,我们的仓库永远都不会遭到     回转或者包含不符合要求信息的提交内容,并且用户都被锁在了沙箱里面。每一个被挂钩拒之门外的索引受到一条远程信息,解释它被拒绝是因为一个挂钩的原因。只要 update 脚本存在并且可执行,我们的仓库永远都不会遭到回转或者包含不符合要求信息的提交内容,并且用户都被锁在了沙箱里面。
       
----------
##*Git内部原理*
----------
    从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统,在此之上提供了一个 VCS 用户界面。由于 Git 一开始被设计成供 VCS 使用的工具集而不是一整套用户友好的 VCS,它还包含了许多底层命令,这些命令用于以 UNIX 风格使用或由脚本调用。这些命令一般被称为 “plumbing” 命令(底层命令),其他的更友好的命令则被称为 “porcelain” 命令(高层命令)。
    
    当你在一个新目录或已有目录内执行 git init 时,Git 会创建一个 .git 目录,几乎所有 Git 存储和操作的内容都位于该目录下。如果你要备份或复制一个库,基本上将这一目录拷贝至其他地方就可以了。本章基本上都讨论该目录下的内容。新版本的 Git 不再使用 branches 目录,description 文件仅供GitWeb 程序使用,所以不用关心这些内容。config 文件包含了项目特有的配置选项,info目录保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件。hooks 目录包住了第六章详细介绍了的客户端或服务端钩子脚本。objects 目录存储所有数据内容,refs 目录存储指向数据 (分支) 的提交对象的指针,HEAD 文件指向当前分支,index 文件保存了暂存区域信息。可以通过底层命令 hash-object 来示范这点,传一些数据给该命令,它会将数据保存在 .git 目录并返回表示这些数据的键值。一个单独的 tree 对象包含一条或多条 tree 记录,每一条记录含有一个指向 blob 或子 tree 对象的 SHA-1 指针,并附有该对象的权限模式 (mode)、类型和文件名信息。要创建一个 tree 对象的话首先要通过将一些文件暂存从而创建一个 index 。可以使用 plumbing 命令 update-index 为一个单独文件 ── test.txt 文件的第一个版本── 创建一个 index 。通过该命令人为的将 test.txt 文件的首个版本加入到了一个新的暂存区域中。由于该文件原先并不在暂存区域中 (甚至就连暂存区域也还没被创建出来呢) ,必须传入 --add 参数;由于要添加的文件并不在当前目录下而是在数据库中,必须传入--cacheinfo 参数。
    用 read-tree 命令将 tree 对象读到暂存区域中去。要创建一个 commit 对象,使用 commit-tree 命令,指定一个 tree 的 SHA-1,如果有任何前继提交对象,也可以指定。
    通过 cat-file 查看这个新 commit 对象,使用 irb 命令进入 Ruby 交互式模式.Git 用 zlib 对数据内容进行压缩,在 Ruby 中可以用 zlib 库来实现。首先需要导入该库,然后用 Zlib::Deflate.deflate() 对数据进行压缩.如果你确实需要更新一个引用,Git 提供了一个安全的命令 update-ref.提交历史查询：git log --pretty=oneline 文件名。HEAD 文件是一个指向你当前所在分支的引用标识符。这样的引用标识符——它看起来并不像一个普通的引用——其实并不包含 SHA-1值,而是一个指向另外一个引用的指针。如果你看一下这个文件,通常你将会看到这样的内容:cat .git/HEAD。如果你执行 git checkout test,Git 就会更新这个文件。Tag 对象非常像一个commit 对象——包含一个标签,一组数据,一个消息和一个指针。最主要的区别就是 Tag对象指向一个 commit 而不是一个 tree。Tag 有两种类型:annotated 和 lightweight 。命令建立一个 lightweight tag:$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d。如果你创建一个 annotated tag,Git 会创建一个 tag 对象,然后写入一个指向指向它而不是直接指向 commit 的 reference。你可以这样创建一个 annotated
tag(-a 参数表明这是一个 annotated tag):git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 –m 'test tag'。如果你添加了一个 remote 然后推送代码过去,Git 会把你最后一次推送到这个 remote 的每个分支的值都记录在 refs/remotes 目录下。Git 往磁盘保存对象时默认使用的格式叫松散对象 (looseobject) 格式。Git 时不时地将这些对象打包至一个叫 packfile 的二进制文件以节省空间并提高效率。当仓库中有太多的松散对象,或是手工调用 git gc 命令,或推送至远程服务器时,Git 都会这样做。索引文件包含了 packfile 的偏移信息,这样就可以快速定位任意一个指定对象。如果QA组成员想把他们的 master 分支推送到远程的 qa/master 分支上,可以这样运行: git push origin master:refs/heads/qa/master.可以使用 refspec 来删除远程的引用,是通过运行这样的命令:$ git push origin :topic,因为 refspec 的格式是 <src>:<dst>, 通过把 <src> 部分留空的方式,这个意思是是把远程的 topic 分支变成空,也就是删除它。
    Git可以以两种主要的方式跨越两个仓库传输数据:基于HTTP协议之上,和 file://,ssh://, 和 git:// 等智能传输协议。Git 基于HTTP之上传输通常被称为哑协议,这是因为它在服务端不需要有针对 Git 特有的代码。这个获取过程仅仅是一系列GET请求,客户端可以假定服务端的Git仓库中的布局。使用智能协议是传送数据的更常用的方法。这些协议在远端都有Git智能型进程在服务 - 它可以读出本地数据并计算出客户端所需要的,并生成合适的数据给它,这有两类传输数据的进程:一对用于上传数据和一对用于下载。为了上传数据至远端, Git 使用 send-pack 和 receive-pack 进程。这个 send-pack 进程运行在客户端上,它连接至远端运行的 receive-pack 进程。当你在下载数据时, fetch-pack 和 upload-pack 进程就起作用了。客户端启动 fetch-pack 进程,连接至远端的 upload-pack 进程,以协商后续数据传输过程。在远端仓库有不同的方式启动 upload-pack 进程。你可以使用与 receive-pack 相同的透过SSH管道的方式,也可以通过 Git 后台来启动这个进程,它默认监听在9418号端口上。这里 fetch-pack 进程在连接后像这样向后台发送数据:003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0它也是以4字节指定后续字节长度的方式开始,然后是要运行的命令,和一个空字节,然后是服务端的主机名,再跟随一个最后的空字节。 Git 后台进程会检查这个命令是否可以运行,以及那个仓库是否存在,以及是否具有公开权限。如果所有检查都通过了,它会启动这个 upload-pack 进程并将客户端的请求移交给它。Git 会不定时地自动运行称为 “auto gc” 的命令。 gc 指垃圾收集 (garbage collect),此命令会做很多工作:收集所有松散对象并将它们存入 packfile,合并这些 packfile 进一个大的 packfile,然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。当查找一个引用的 SHA 时,Git 首先在 refs 目录下查找,如果未找到则到 packed-refs 文件中去查找。因此如果在 refs 目录下找不到一个引用,该引用可能存到 packed-refs 文件中去了.任何时间运行 git reflog命令可以查看当前的状态.当你提交或修改分支时,reflog 就会更新。git update-ref 命令也可以更新 reflog.假设引起 commit 丢失的原因并没有记录在 reflog 中 ── 可以通过删除recover-branch 和 reflog 来模拟这种情况。这样最新的两个 commit 不会被任何东西引用到:git branch –D recover-branch rm -Rf .git/logs/因为 reflog 数据是保存在 .git/logs/ 目录下的,这样就没有 reflog 了。 git fsck工具会检查仓库的数据完整性。如果指定 --ful 选项,该命令显示所有未被其他对象引用 (指向) 的所有对象。为了移除对一个大文件的引用,从最早包含该引用的tree 对象开始之后的所有 commit 对象都会被重写。如果在刚导入一个仓库并在其他人在此基础上开始工作之前这么做,那没有什么问题 ── 否则你不得不通知所有协作者 (贡献者) 去衍合你新修改的 commit。可以运行 count-objects 以查看使用了多少空间。运行 git gc,所有对象会存入一个 packfile。文件;运行另一个底层命令 git verify-pack 以识别出大对象,对输出的第三列信息即文件大小进行排序,还可以将输出定向到 tail 命令。如果真的要完全把这个对象删除,可以运行 git prune --expire命令。



 
